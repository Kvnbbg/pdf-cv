/**
 * Created by wangtieshan on 2017/10/28.
 */

import { NativeModules } from 'react-native';

export const nativeFileManager = NativeModules.EFileManager;

let SandBoxPath = '';

export class EFileManager {

    /**
     * 沙盒标准路径。
     * 原生将会为每个小程序创建一个基础文件夹。标准路径就是小程序文件夹
     * @returns {*}
     */
    static stand(): EFileManager {
        return new EFileManager()
    }

    /**
     * 沙盒缓存路径。
     * 原生将会为每个小程序创建一个基础文件夹，在小程序文件夹中创建的 Caches 文件夹
     * @returns {*}
     */
    static cache(): EFileManager {
        return new EFileManager('Caches/')
    }

    /**
     * 基础文件夹，模块下的文件夹
     * @type {string}
     * @private
     */
    _baseDirectoryPath: string = '';

    /**
     * 相对于模块文件夹下
     * 基础路径，方法中所操作的路径都会添加前置增加baseDir
     */
    baseDir: string = '';

    /**
     * 模块名称
     * @type {string}
     */
    moduleName: string = 'EReactMiniProgram';

    /**
     * 构造函数
     * @param baseDir 基础路径
     * @param moduleName 模块名称，对应原生的文件夹
     */
    constructor(baseDir: string, moduleName: string) {
        if (baseDir) {
            this.baseDir = baseDir;
        }
        if (moduleName) {
            this.moduleName = moduleName;
        }
        this._baseDirectoryPath = nativeFileManager.getSandBoxBasePath(this.moduleName)
    }

    /**
     * 沙盒基础路径
     * @returns {*} 沙盒中的基础路径
     */
    sandBaseBoxPath(): string {
        if (!this._baseDirectoryPath) {
            this._baseDirectoryPath = nativeFileManager.getSandBoxBasePath(this.moduleName)
        }
        return this._baseDirectoryPath;
    }

    /**
     * 沙盒中的完整路径
     * @param path 沙盒中的相对路径
     */
    fullPath(path: string) {
        return this._sandBoxPathFull(path);
    }

    /**
     * 生成沙盒相对路径
     * @param path
     * @returns {string} 沙盒中的相对路径
     */
    subPath(path: string): string {
        return this._subPath(path);
    }

    /**
     * 文件是否存在
     * 【注】path 为沙盒相对路径
     * @param options 参数
     */
    fileExist(options: {
        path: string,
        res: (boolean) => void
    }) {
        const { path, res } = options;
        if (!path || !res) { return }
        this.fileInfo(this.subPath(path), this.moduleName, (data)=>{
            res(data.exist);
        })
    }

    /**
     * 文件夹是否存在
     * 【注】path 为沙盒相对路径
     * @param options 参数
     */
    directoryExist(options: {
        path: string,
        res: (boolean) => void
    }) {
        const { path, res } = options;
        if (!path || !res) { return }
        this.fileInfo(this.subPath(path), this.moduleName, (data)=>{
            res(!!data.isDirectory);
        })
    }

    /**
     *路径下是否是文件夹
     * 【注】path 为沙盒相对路径
     * @param options 参数
     */
    isDirectory(options: {
        path: string,
        res: (boolean) => void
    }) {
        const { path, res } = options;
        if (!path || !res) { return }
        this.fileInfo(this.subPath(path), this.moduleName, (data)=>{
            res(!!data.isDirectory);
        })
    }

    /**
     * 移动文件
     * 【注】path, toPath 为沙盒相对路径
     * @param options 参数
     */
    move(options: {
        path: string,
        toPath: string,
        res: ({ path: string, subPath: string, toPath: string, toSubPath: string, success: boolean }) => void
    }) {
        const { path, toPath, res } = options;
        if (!path || !toPath || !res) { return }
        nativeFileManager.move(this.subPath(path), this.moduleName, this.subPath(toPath), (error, data)=>{
            if (error) {
                res({ success: false });
            } else if (data) {
                try {
                    res(JSON.parse(data));
                } catch (e) {
                    res({ success: false })
                }
            }
        });
    }

    /**
     * 文件夹信息
     * 【注】path 为沙盒相对路径
     * @param options
     */
    fileInfo(options: {
        path: string,
        res: ({ exist: boolean, isDirectory: boolean, path: string, subPath: string, success: boolean })=>void
    }) {
        const { path, res } = options;
        if (!path || !res) { return }
        nativeFileManager.fileInfo(this.subPath(path), this.moduleName, (error, data)=>{
            if (data) {
                try {
                    res({ ...JSON.parse(data), success: true});
                } catch (e) {
                    res({ success: false })
                }
            } else {
                res({ success: false });
            }
        })
    }

    /**
     * 创建文件夹
     * 【注】path 为沙盒相对路径
     * @param options 配置
     */
    createDirectory(options: {
        path: string,
        res: ({ path: string, subPath: string, success: boolean })=>void
    }) {
        const { path, res } = options;
        if (!path || !res) { return }
        nativeFileManager.createDirectory(this.subPath(path), this.moduleName, (error, data)=>{
            if (data) {
                try {
                    res(...JSON.parse(data));
                } catch (e) {
                    res({ success: false })
                }
            } else {
                res({ success: false });
            }
        })
    }

    /**
     * 删除文件夹/文件
     * 【注】path 为沙盒相对路径
     * @param options 配置
     */
    removeItem(options: {
        path: string,
        res: ({ path: string, subPath: string, success: boolean })=>void
    }) {
        const { path, res } = options;
        if (!path || !res) { return }
        nativeFileManager.removeItem(this.subPath(path), this.moduleName, (error, data)=>{
            if (data) {
                try {
                    res(...JSON.parse(data));
                } catch (e) {
                    res({ success: false })
                }
            } else {
                res({ success: false });
            }
        })
    }

    /**
     * 沙盒录路径
     * @param path
     * @returns {string}
     * @private
     */
    _sandBoxPathFull(path): string {
        return `${SandBoxPath}/${this._subPath(path)}`
    }

    /**
     * RN 里面所持有的路径
     * @param path
     * @returns {string}
     * @private
     */
    _subPath(path: string): string {
        // 本身就已经含有基础文件夹，则不重复添加
        if (path === '' || !this.baseDir || path.startsWith(this.baseDir)) { return path }
        return this.baseDir + this._decoratePath(path) ;
    }

    /**
     * 将第一个和最后一个的 / 去掉
     * @param path
     * @returns {string}
     * @private
     */
    _decoratePath(path): string {
        return path.replace('^/', '').replace('/$', '')
    }
}
