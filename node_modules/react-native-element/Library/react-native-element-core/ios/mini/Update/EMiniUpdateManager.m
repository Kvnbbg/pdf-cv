//
//  EMiniUpdateManager.m
//  reactnativeelement
//
//  Created by 王铁山 on 2018/5/11.
//  Copyright © 2018年 王铁山. All rights reserved.
//

#import "EMiniUpdateManager.h"

#import "EMiniApi.h"

#import "EMiniTool.h"

#import "EMiniInfoModel.h"

#import "EMiniNet.h"

#import <ZipArchive/ZipArchive.h>

#import "EMiniViewManager.h"

#import "DiffMatchPatch.h"

#import <CommonCrypto/CommonDigest.h>

@interface EMiniUpdateManager()
{
    BOOL _updating;
    
    /// 同步线程。保证 更新 _updaing 和 查询 _updating在一个同步线程中。
    dispatch_queue_t _queue;
}
/**
 检查更新的剩余时间
 */
@property(nonatomic, assign)double checkUpdateTimerLeft;

/**
 检查更新最低时间所开定时器
 */
@property(nonatomic, strong)NSTimer * checkUpdateTimer;

/**
 api
 */
@property(nonatomic, strong)EMiniApi * miniApi;

@end

@implementation EMiniUpdateManager

- (instancetype)init:(NSString *)miniId {
    self = [super init];
    if (self) {
        self.miniId = miniId;
        self.miniTime = 0.25;
        _updating = false;
        self.miniApi = [[EMiniApi alloc] init:miniId];
        _queue = dispatch_queue_create([miniId cStringUsingEncoding:NSUTF8StringEncoding], DISPATCH_QUEUE_SERIAL);
    }
    return self;
}

- (void)checkUpdate {
    
    __weak typeof(EMiniUpdateManager *)wSelf = self;
    
    dispatch_async(_queue, ^{
        
        if (_updating) { return; }
        
        // [self getInfo];
        
        self.checkUpdateTimerLeft = self.miniTime;
        
        self.checkUpdateTimer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(checkUpdateTimerDismiss) userInfo:nil repeats:true];
        
        EMiniLog([NSString stringWithFormat: @"开始网络请求获取更新数据：%@", self.miniId]);
        
        _updating = true;
        
        [self.miniApi getUpdateInfo:^(RNUpdateModel * model) {
            
            if (self.checkUpdateTimerLeft <= 0) {
                [self dealForResponse:model response:nil error:nil];
            } else {
                [self.checkUpdateTimer invalidate];
                self.checkUpdateTimer = nil;
                EMiniMainAfter(self.checkUpdateTimerLeft, ^{
                    [self dealForResponse:model response:nil error:nil];
                });
            }
        } error:^(EMiniError error) {
            dispatch_async(_queue, ^{
                if (error == EMiniErrorNet) {
                    [self logError: EMiniErrorNet];
                    [wSelf.delegate showNetError];
                } else {
                    [self logError: EMiniErrorNotFound];
                    [wSelf.delegate showNotFindMini];
                }
                _updating = false;
            });
        }];
    });
    
}

- (void)checkUpdateTimerDismiss {
    self.checkUpdateTimerLeft -= 0.1;
    if (self.checkUpdateTimerLeft <= 0) {
        [self.checkUpdateTimer invalidate];
        self.checkUpdateTimer = nil;
    }
}

- (void)getInfo {
    __weak typeof(EMiniUpdateManager *)wSelf = self;
    // 1. 加载本地
    EMiniInfoModel * local = [self.miniApi getCachedMiniInfo];
    if (local) {
        [self.delegate loadMiniInfo:local];
        [self.miniApi downLoadIcon:local.iconURL result:^(UIImage *image) {
            [wSelf.delegate loadMiniIcon:image];
        }];
    }
    // 2. 请求远端
    [self.miniApi getInfo:^(EMiniInfoModel * model) {
        if (model) {
            if (local && local.version == model.version) {
                return;
            }
            [wSelf.delegate loadMiniInfo:model];
            [wSelf.miniApi downLoadIcon:model.iconURL result:^(UIImage *image) {
                [wSelf.delegate loadMiniIcon:image];
            }];
        }
    } error:^(EMiniError error) {
        
    }];
}

- (void)dealForResponse:(RNUpdateModel *)model response: (NSURLResponse *)response error: (NSError *)error {
    dispatch_async(_queue, ^{
        if (!model) {
            if (self.delegate && [self.delegate respondsToSelector:@selector(showNotFindMini)]) {
                [self.delegate showNotFindMini];
            }
            [self logError: EMiniErrorNotFound];
            _updating = false;
            return;
        }
        
        int remoteVersion = model.version;
        
        if ([self.miniApi bundleExist:remoteVersion] && ![self.miniApi bundlePatchExist:remoteVersion]) {
            NSString * log = ([self.miniApi version] != remoteVersion ? @"本地已经缓存最新版本" : @"已经是最新版本");
            EMiniLog([NSString stringWithFormat:@"无需更新，%@：%@ :%ld", log, self.miniId, remoteVersion]);
            [EMiniViewManager setHasCheckUpdate:self.miniId];
            [self.miniApi updateVersion:remoteVersion];
            [self loadLocalVersion:remoteVersion];
            _updating = false;
        } else {
            /// 补丁更新的要求。非整包更新，补丁对象存在，本地 version 包存在，却不存在 patch 文件
            if (!model.fullupdate && model.patch && [self.miniApi bundleExist:[self.miniApi version]] && ![self.miniApi bundlePatchExist:[self.miniApi version]]) {
                EMiniLog([NSString stringWithFormat:@"开始补丁包更新：%@", self.miniId]);
                [self beginPatchUpdate:model version:remoteVersion];
            } else {
                EMiniLog([NSString stringWithFormat:@"开始整包更新：%@", self.miniId]);
                [self beginFullUpdate:model version:remoteVersion];
            }
        }
    });
}

/// 补丁更新
- (void)beginPatchUpdate:(RNUpdateModel *)model version:(int)version {
    
    /// 空补丁
    if (model.patch.empty) {
        EMiniLog([NSString stringWithFormat:@"无需更新。无补丁，最新版本和本地版本一致：%@", self.miniId]);
        EMiniLog([NSString stringWithFormat:@"拷贝本地版本到最新版本目录下：%@", self.miniId]);
        int localVersion = [self.miniApi version];
        NSString * localPath = [self.miniApi bundleDirectory:localVersion];
        NSString * targetPath = [self.miniApi bundleDirectory:version];
        [[NSFileManager defaultManager] removeItemAtPath:targetPath error:nil];
        BOOL copy = [[NSFileManager defaultManager] copyItemAtPath:localPath toPath:targetPath error:nil];
        if (!copy) {
            [self logError: EMiniErrorCopy];
            EMiniLog([NSString stringWithFormat:@"失败，拷贝本地版本到最新版本目录下失败 %@", self.miniId]);
            EMiniLog([NSString stringWithFormat:@"转换为整包更新：%@", self.miniId]);
            [self beginFullUpdate:model version:version];
            return;
        } else {
            [EMiniViewManager setHasCheckUpdate:self.miniId];
            [self.miniApi updateVersion:version];
        }
        EMiniLog([NSString stringWithFormat:@"更新成功：%@ : %d", self.miniId, version]);
        [self loadLocalVersion:localVersion];
        _updating = false;
        return;
    }
    
    if (!model.patch.path) {
        [self logError: EMiniErrorNotFoundPatchZIPPath];
        EMiniLog([NSString stringWithFormat:@"转换为整包更新：%@", self.miniId]);
        [self beginFullUpdate:model version:version];
        return;
    }
    
    EMiniRequest * request = [[EMiniNet share] downLoadByPath:model.patch.path];
    
    [request setProgress:^(double progress) {
        [self.delegate updatePrgress:progress];
    }];
    
    [request setComplete:^(NSString * data, NSURLResponse * response, NSError * error) {
        dispatch_async(_queue, ^{
            if (error) {
                [self logError: EMiniErrorNet];
                EMiniLog([NSString stringWithFormat:@"转换为整包更新：%@", self.miniId]);
                [self beginFullUpdate:model version:version];
                return;
            }
            if (data) {
                [self dealPatchZip:data model:model version:version];
            } else {
                [self logError: EMiniErrorPatchZIPDownLoad];
                EMiniLog([NSString stringWithFormat:@"转换为整包更新：%@", self.miniId]);
                [self beginFullUpdate:model version:version];
            }
        });
    }];
}

- (void) dealPatchZip:(NSString *)location model:(RNUpdateModel *)model version: (int)version {
    
    // 1. 将本地版本文件拷贝到最新版本目录下
    // 2. 删除最新版本目录下 patch 文件，防止影响
    // 3. 覆盖式解压 补丁zip文件到最新版本目录下
    // 4. 检测是否存在 patch 文件，存在的话，开始补丁合并
    // 5. 删除最新版本下 patch 文件
    
    // 1. 将本地版本文件拷贝到最新版本目录下
    EMiniLog([NSString stringWithFormat:@"拷贝本地版本到最新版本目录下：%@", self.miniId]);
    int localVersion = [self.miniApi version];
    NSString * localPath = [self.miniApi bundleDirectory:localVersion];
    NSString * targetPath = [self.miniApi bundleDirectory:version];
    [[NSFileManager defaultManager] removeItemAtPath:targetPath error:nil];
    BOOL copy = [[NSFileManager defaultManager] copyItemAtPath:localPath toPath:targetPath error:nil];
    if (!copy) {
        [self logError: EMiniErrorCopy];
        EMiniLog([NSString stringWithFormat:@"失败，拷贝本地版本到最新版本目录下失败，转换为整包更新：%@", self.miniId]);
        [self beginFullUpdate:model version:version];
        return;
    }
    
    
    // 2. 删除最新版本目录下 patch 文件，防止影响
    NSString * targetPatchPath = [targetPath stringByAppendingPathComponent:@"patch"];
    if ([[NSFileManager defaultManager] fileExistsAtPath:targetPatchPath isDirectory:nil]) {
        [[NSFileManager defaultManager] removeItemAtPath:targetPatchPath error:nil];
        EMiniLog([NSString stringWithFormat:@"删除目录下的 patch 文件：%@", self.miniId]);
    }
    
    // 3. 覆盖式解压 补丁zip文件到最新版本目录下
    ZipArchive * un = [[ZipArchive alloc] init];
    BOOL open = [un UnzipOpenFile:location];
    BOOL result = [un UnzipFileTo:targetPath overWrite:true];
    [un CloseZipFile2];
    
    [[NSFileManager defaultManager] removeItemAtPath:location error:nil];
    EMiniLog([NSString stringWithFormat:@"清除下载的缓存 patch ZIP 文件：%@", self.miniId]);
    
    if (!open || !result) {
        [self logError: EMiniErrorPatchUNZIP];
        EMiniLog([NSString stringWithFormat:@"转换为整包更新：%@", self.miniId]);
        [self beginFullUpdate:model version:version];
        return;
    }
    
    void(^applyFail)() = ^{
        [[NSFileManager defaultManager] removeItemAtPath:targetPath error:nil];
        [self logError: EMiniErrorPatchApply];
        EMiniLog([NSString stringWithFormat:@"转换为整包更新：%@", self.miniId]);
        [self beginFullUpdate:model version:version];
    };
    
    // 4. 检测是否存在 patch 文件，存在的话，开始补丁合并
    if ([[NSFileManager defaultManager] fileExistsAtPath:targetPatchPath isDirectory:nil]) {
        
        NSString * targetIndexPath = [self.miniApi bundlePath:version];
        NSError * read_origin_error;
        NSString * orgin_code = [[NSString alloc] initWithData:[NSData dataWithContentsOfFile:targetIndexPath] encoding:NSUTF8StringEncoding];
        
        // 读取 index.jsbundle 内容失败
        if (read_origin_error || !orgin_code) {
            applyFail();
            return;
        }

        NSError * read_patch_error;
        NSString * patch_code = [[NSString alloc] initWithData:[NSData dataWithContentsOfFile:targetPatchPath] encoding:NSUTF8StringEncoding];
        
        // 读取 patch 内容失败
        if (read_patch_error || !patch_code) {
            applyFail();
            return;
        }
        
        DiffMatchPatch * diff = [[DiffMatchPatch alloc] init];
        
        // 字符串转换为 对象
        NSError * patch_trans_error;
        NSArray * patch_arr = [diff patch_fromText:patch_code error:&patch_trans_error];
        if (patch_trans_error || !patch_arr) {
            applyFail();
            return;
        }
        
        // 应用
        NSArray * apply_result = [diff patch_apply:patch_arr toString:orgin_code];
        if (!apply_result || !apply_result.count || ![apply_result[0] isKindOfClass:[NSString class]]) {
            applyFail();
            return;
        }
        
        // 结果
        NSString * result = apply_result[0];
        
        BOOL write = [result writeToFile:targetIndexPath atomically:true encoding:NSUTF8StringEncoding error:nil];
        
        if (!write) {
            applyFail();
            return;
        }
        
        [[NSFileManager defaultManager] removeItemAtPath:targetPatchPath error:nil];
    }
    
    BOOL isSuccess = false;
    
    if ([self.miniApi bundleExist:version]) {
        
        BOOL checkMd5 = true;
        
        /// 当存在 md5 时，做md5 的校验
        if (model.secret && ![model.secret isEqualToString:@""]) {
            
            /// index.jsbundle path
            NSString * bundlePath = [self.miniApi bundlePath:version];
            
            NSString * bundleContent = [[NSString alloc] initWithContentsOfFile:bundlePath encoding:NSUTF8StringEncoding error:nil] ?: @"";
            
            NSString * md5 = [self md5:bundleContent];
            
            checkMd5 = [md5 isEqualToString:model.secret.uppercaseString];
        }
        
        if (checkMd5) {
            
            isSuccess = true;
            
            [self.miniApi updateVersion:model.version];
            
            [EMiniViewManager setHasCheckUpdate:self.miniId];
            
            [self loadLocalVersion:model.version];
            
            EMiniLog([NSString stringWithFormat:@"更新成功：%@-%ld", self.miniId, model.version]);
            
            _updating = false;
        } else {
            [self logError:EMiniErrorMD5];
        }
    } else {
        [self logError:EMiniErrorPatchApply];
    }
    
    if (!isSuccess) {
        [[NSFileManager defaultManager] removeItemAtPath:targetPath error:nil];
        EMiniLog([NSString stringWithFormat:@"转换为整包更新：%@", self.miniId]);
        [self beginFullUpdate:model version:version];
    }
    
}

/// 整包更新
- (void)beginFullUpdate:(RNUpdateModel *)model version:(int)version {
    
    if (!model.path) {
        [self logError: EMiniErrorNotFoundZIPPath];
        if (!model.forceupdate && [self.miniApi bundleExist:[self.miniApi version]]) {
            [self loadLocalVersion:version];
        } else {
            [self delegateShowDataError:EMiniErrorNotFoundZIPPath];
        }
        _updating = false;
        return;
    }
    
    EMiniRequest * request = [[EMiniNet share] downLoadByPath:model.path];
    
    [request setProgress:^(double progress) {
        [self.delegate updatePrgress:progress];
    }];
    
    [request setComplete:^(NSString * data, NSURLResponse * response, NSError * error) {
        dispatch_async(_queue, ^{
            if (error) {
                [self logError: EMiniErrorNet];
                if (!model.forceupdate && [self.miniApi bundleExist:[self.miniApi version]]) {
                    [self loadLocalVersion:version];
                } else {
                    [self.delegate showNetError];
                }
                _updating = false;
                return;
            }
            if (data) {
                [self dealFullZip:data model:model version:version];
            } else {
                [self logError: EMiniErrorZIPDownLoad];
                if (!model.forceupdate && [self.miniApi bundleExist:[self.miniApi version]]) {
                    [self loadLocalVersion:version];
                } else {
                    [self delegateShowDataError:EMiniErrorZIPDownLoad];
                }
                _updating = false;
            }
        });
    }];
    
}

- (void) dealFullZip:(NSString *)location model:(RNUpdateModel *)model version: (int)version {
    
    NSString * targetPath = [self.miniApi bundleDirectory:model.version];
    
    if (targetPath) {
        [[NSFileManager defaultManager] removeItemAtPath:targetPath error:nil];
    }
    
    ZipArchive * un = [[ZipArchive alloc] init];
    BOOL open = [un UnzipOpenFile:location];
    BOOL result = [un UnzipFileTo: targetPath overWrite:true];
    [un CloseZipFile2];
    
    if (!open || !result) {
        [self logError: EMiniErrorUNZIP];
        if (!model.forceupdate && [self.miniApi bundleExist:[self.miniApi version]]) {
            [self loadLocalVersion:version];
        } else {
            [self delegateShowDataError:EMiniErrorUNZIP];
        }
        _updating = false;
        return;
    }
    
    BOOL isSuccess = false;
    
    if ([self.miniApi bundleExist:version]) {
        
        BOOL checkMd5 = true;
        
        /// 当存在 md5 时，做md5 的校验
        if (model.secret && ![model.secret isEqualToString:@""]) {
            
            /// index.jsbundle path
            NSString * bundlePath = [self.miniApi bundlePath:version];
            
            NSString * bundleContent = [[NSString alloc] initWithContentsOfFile:bundlePath encoding:NSUTF8StringEncoding error:nil] ?: @"";
            
            NSString * md5 = [self md5:bundleContent];
            
            checkMd5 = [md5 isEqualToString:model.secret.uppercaseString];
        }
        
        if (checkMd5) {
            
            isSuccess = true;
            
            [self.miniApi updateVersion:model.version];
            
            [EMiniViewManager setHasCheckUpdate:self.miniId];
            
            [self loadLocalVersion:model.version];
            
            EMiniLog([NSString stringWithFormat:@"更新成功：%@-%ld", self.miniId, model.version]);
            
        } else {
            [self logError:EMiniErrorMD5];
            EMiniLog([NSString stringWithFormat:@"更新失败，md5 不匹配：%@-%ld", self.miniId, model.version]);
        }
    } else {
        [self logError:EMiniErrorUNZIP];
        EMiniLog([NSString stringWithFormat:@"更新失败，解压包问题：%@-%ld", self.miniId, model.version]);
    }
    
    if (!isSuccess) {
        
        [[NSFileManager defaultManager] removeItemAtPath:targetPath error:nil];
        
        if (!model.forceupdate && [self.miniApi bundleExist:[self.miniApi version]]) {
            [self loadLocalVersion:version];
        }
    }
    
    _updating = false;
    
}

- (void)loadLocalVersion:(int)version {
    if (self.delegate && [self.delegate respondsToSelector:@selector(loadLocalVersion:)]) {
        [self.delegate loadLocalVersion:[self.miniApi bundlePath:[self.miniApi version]]];
    }
}

- (void)syncCheckUpdating:(void (^)(BOOL, EMiniUpdateManager *))check {
    dispatch_async(_queue, ^{
        check(_updating, self);
    });
}

- (void)delegateShowDataError: (EMiniError )error {
    if (self.delegate) {
        [self.delegate showDataError:[NSString stringWithFormat:@"UP%ld", error]];
    }
}

- (void)logError: (EMiniError)error {
    EMiniLog([NSString stringWithFormat:@"更新失败：%@ \ncode:%ld \nmessage:%@", self.miniId, error, [self errDesc: error]]);
}

- (NSString *)errDesc: (EMiniError)error {
    switch (error) {
        case EMiniErrorNet:
            return @"网络错误";
        case EMiniErrorNotFound:
            return @"没有发现此小程序";
        case EMiniErrorNotFoundZIPPath:
            return @"没有发现此小程序更新路径";
        case EMiniErrorZIPDownLoad:
            return @"更新包下载失败";
        case EMiniErrorUNZIP:
            return @"更新包解压失败";
        case EMiniErrorUnknow:
            return @"网络错误";
        case EMiniErrorMD5:
            return @"md5 不匹配";
        default:
            return @"未知错误";
    }
}

- (NSString *)md5: (NSString *)string {
    const char *cStr = [string UTF8String];
    unsigned char result[32];
    CC_MD5(cStr, (CC_LONG)strlen(cStr), result); // This is the md5 call
    
    return [[NSString stringWithFormat:
             @"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
             result[0], result[1], result[2], result[3],
             result[4], result[5], result[6], result[7],
             result[8], result[9], result[10], result[11],
             result[12], result[13], result[14], result[15]
             ] uppercaseString];
}

@end
