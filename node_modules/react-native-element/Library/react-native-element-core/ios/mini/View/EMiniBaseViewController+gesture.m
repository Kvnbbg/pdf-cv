//
//  EMiniBaseViewController+gesture.m
//  reactnativeelement
//
//  Created by 王铁山 on 2018/6/14.
//  Copyright © 2018年 王铁山. All rights reserved.
//

#import "EMiniBaseViewController+gesture.h"

#import "EMiniViewManager.h"

#import <objc/runtime.h>

static char _enableEdgDismiss;

static char _enableEdgGes;

@implementation EMiniBaseViewController (gesture)

- (void)edgToDismiss: (UIScreenEdgePanGestureRecognizer *)edgGes {
    UIView * targetView = self.contentView;
    
    if (edgGes.state == UIGestureRecognizerStateEnded ||
        edgGes.state == UIGestureRecognizerStateFailed ||
        edgGes.state == UIGestureRecognizerStateCancelled) {
        
        __block CGRect frame = targetView.frame;
        
        if (frame.origin.x > frame.size.width / 3.0) {
            [[EMiniViewManager share] dismissMiniId:self.miniId uuid:self.uuid];
        } else {
            [UIView animateWithDuration:0.25 animations:^{
                
                frame.origin.x = 0;
                
                targetView.frame = frame;
            }];
        }
        
    } else if (edgGes.state == UIGestureRecognizerStateChanged) {
        CGSize size = [UIScreen mainScreen].bounds.size;
        
        CGPoint point = [edgGes locationInView:self.view];
        
        CGFloat x = point.x;
        
        CGFloat move = x;
        
        CGRect frame = targetView.frame;
        
        frame.origin.x = move;
        
        targetView.frame = frame;
    }
    /*
    UIView * targetView = self.contentView;
    
    if (edgGes.state == UIGestureRecognizerStateEnded ||
        edgGes.state == UIGestureRecognizerStateFailed ||
        edgGes.state == UIGestureRecognizerStateCancelled) {
        
        __block CGRect frame = targetView.frame;
        
        if (frame.origin.y > frame.size.height / 3.0) {
            [[EMiniViewManager share] dismissMiniId:self.miniId uuid:self.uuid];
        } else {
            [UIView animateWithDuration:0.25 animations:^{
                
                frame.origin.y = 0;
                
                targetView.frame = frame;
            }];
        }
        
    } else if (edgGes.state == UIGestureRecognizerStateChanged) {
        CGSize size = [UIScreen mainScreen].bounds.size;
        
        CGPoint point = [edgGes locationInView:self.view];
        
        CGFloat x = point.x;
        
        CGFloat move = x * (size.width > size.height ? 1 : 2);
        
        CGRect frame = targetView.frame;
        
        frame.origin.y = move;
        
        targetView.frame = frame;
    }
    */
}

- (BOOL)enableEdgDismiss {
    if (self.transitionStyle != EMiniTransitionStylePresentLikePush) {return false;}
    return [objc_getAssociatedObject(self, &_enableEdgDismiss) boolValue];
}

- (void)setEnableEdgDismiss:(BOOL)enableEdgDismiss {
    
    if (self.transitionStyle != EMiniTransitionStylePresentLikePush) {return;}
    
    objc_setAssociatedObject(self, &_enableEdgDismiss, @(enableEdgDismiss ? 1 : 0), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    
    if (enableEdgDismiss) {
        if (self.edgeGesture) { return; }
        UIScreenEdgePanGestureRecognizer * edg = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(edgToDismiss:)];
        edg.edges = UIRectEdgeLeft;
        [self.view addGestureRecognizer:edg];
        self.edgeGesture = edg;
    } else {
        if (self.edgeGesture) {
            [self.view removeGestureRecognizer:self.edgeGesture];
            self.edgeGesture = nil;
        }
    }
    
}

- (UIScreenEdgePanGestureRecognizer *)edgeGesture {
    return objc_getAssociatedObject(self, &_enableEdgGes);
}

- (void)setEdgeGesture:(UIScreenEdgePanGestureRecognizer *)edgeGesture{

    objc_setAssociatedObject(self, &_enableEdgGes, edgeGesture, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    
}
@end
