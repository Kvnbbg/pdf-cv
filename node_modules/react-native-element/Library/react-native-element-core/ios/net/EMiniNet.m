//
//  EMiniNet.m
//  EMiniNet
//
//  Created by 王铁山 on 2018/5/10.
//  Copyright © 2018年 王铁山. All rights reserved.
//

#import "EMiniNet.h"

#import "EMiniTool.h"

const EMiniRequestNotificationKey * EMiniRequestNotificationKeyDidResume = @"EMiniRequestNotificationKeyDidResume";

const EMiniRequestNotificationKey * EMiniRequestNotificationKeyDidComplete = @"EMiniRequestNotificationKeyDidComplete";

@implementation EMiniRequest

- (instancetype)init:(NSString *)path
{
    self = [super init];
    if (self) {
        if (path) {
            NSMutableCharacterSet * set = [[NSMutableCharacterSet alloc] init];
            
            [set formUnionWithCharacterSet:[NSCharacterSet URLHostAllowedCharacterSet]];
            
            [set formUnionWithCharacterSet:[NSCharacterSet URLPathAllowedCharacterSet]];
            
            [set formUnionWithCharacterSet:[NSCharacterSet URLQueryAllowedCharacterSet]];
            
            self.path = [path stringByAddingPercentEncodingWithAllowedCharacters:set.copy];
        } else {
            self.path = path;
        }
        self.httpMethod = @"POST";
        self.contentType = @"application/json";
        self.responseEncoding = NSUTF8StringEncoding;
    }
    return self;
}

@end


@implementation EMiniUploadRequest

@end


@interface EMiniNet()<NSURLSessionDownloadDelegate>

@property(nonatomic, strong)NSMutableArray * tasks;

@end

@implementation EMiniNet

+(instancetype)share {
    static EMiniNet * share;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        if (!share) {
            share = [[EMiniNet alloc] init];
            share.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]  delegate:share delegateQueue:nil];
        }
    });
    return share;
}

+(instancetype)background {
    static EMiniNet * share;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        if (!share) {
            share = [[EMiniNet alloc] init];
            share.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@"com.reactnative.e.net.background"]  delegate:share delegateQueue:nil];
            
        }
    });
    return share;
}

- (instancetype)init
{
    self = [super init];
    if (self) {
        self.defaultHeaders = @{@"platform": @"ios"};
        self.tasks = [NSMutableArray array];
    }
    return self;
}

// MARK: - data task get post

-(NSURLSessionTask *)get:(NSString *)path params:(NSDictionary *)params header: (NSDictionary *)header {
    
    EMiniRequest * request = [[EMiniRequest alloc] init:path];
    
    request.httpMethod = @"GET";
    
    request.header = header;
    
    request.body = params;
    
    return [self reqeust:request];
    
}

-(NSURLSessionTask *)post:(NSString *)path params:(NSDictionary *)params header: (NSDictionary *)header {
    
    EMiniRequest * request = [[EMiniRequest alloc] init:path];
    
    request.httpMethod = @"POST";
    
    request.header = header;
    
    request.body = params;
    
    return [self reqeust:request];
    
}
            
-(NSURLSessionTask *)reqeust:(EMiniRequest *)request {
    
    NSString * path = request.path ?: @"";
    
    NSURL * url = [[NSURL alloc] initWithString:path];
    
    if (!url) {
        EMiniMainSafe(^{
            request.complete(nil, nil, [NSError errorWithDomain:@"com.reactnative.neterror" code:NSURLErrorBadURL userInfo:nil]);
        });
        return nil;
    }
    
    if (request.body) {
        
        if ([request.httpMethod.uppercaseString isEqualToString:@"GET"]) {
            
            if ([request.body isKindOfClass:[NSDictionary class]]) {
                NSURLComponents * components =  [[NSURLComponents alloc] initWithURL:url resolvingAgainstBaseURL:false];
                NSMutableArray * items = [NSMutableArray arrayWithArray:components.queryItems ?: @[]];
                for (NSString * key in request.body) {
                    NSURLQueryItem * item = [[NSURLQueryItem alloc] initWithName:key value: [request.body[key] description]];
                    [items addObject:item];
                }
                components.queryItems = items.copy;
                url = components.URL;
            }
        }
    }
    
    NSMutableURLRequest * r = [[NSMutableURLRequest alloc] initWithURL:url];
    
    if (request.body && [request.httpMethod.uppercaseString isEqualToString:@"POST"]) {
        r.HTTPBody = [[EMiniTool objToString:request.body] dataUsingEncoding:NSUTF8StringEncoding];
    }
    
    r.HTTPMethod = request.httpMethod;
    
    [r setValue:request.contentType forHTTPHeaderField:@"Content-Type"];
    
    if (request.header) {
        for (NSString *key in request.header) {
            [r setValue:request.header[key] forHTTPHeaderField:key];
        }
    }
    for (NSString *key in self.defaultHeaders) {
        [r setValue:request.header[key] forHTTPHeaderField:key];
    }
    
    __weak typeof(EMiniNet *) wSelf = self;
    
    NSURLSessionDataTask * task = [self.session dataTaskWithRequest:r completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        EMiniMainSafe(^{
            [wSelf dealForHttpMethod:request data:data response:response error:error];
            [self removeRequest:request];
        });
    }];
    
    request.task = task;
    
    [self addRequest:request];
    
    [task resume];
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:EMiniRequestNotificationKeyDidResume object:task];
    });
    
    return task;
    
}

-(void)dealForHttpMethod:(EMiniRequest *)request data: (NSData *)data response: (NSURLResponse *)response error: (NSError *)error {
    
    if (error) {
        request.complete(nil, response, error);
        return;
    }
    
    if (!data) {
        request.complete(nil, response, error);
        return;
    }
    
    id obj;
    
    @try {
        NSError * error;
        obj = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&error];
        if (!obj) {
            obj = [[NSString alloc] initWithData:data encoding:request.responseEncoding];
        }
    } @catch (NSException *exception) {
        obj = [[NSString alloc] initWithData:data encoding:request.responseEncoding];
    } @finally {
        
    }
    
    request.complete(obj, response, error);
    
    NSURLSessionTask * task = request.task;
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        NSMutableDictionary * nf = [NSMutableDictionary dictionary];
        
        if (task) {
            nf[@"task"] = task;
        }
        
        if (obj) {
            nf[@"object"] = obj;
        }
        
        if (response) {
            nf[@"response"] = response;
        }
        
        if (error) {
            nf[@"error"] = error;
        }
        
        request.task = nil;
        
        [[NSNotificationCenter defaultCenter] postNotificationName:EMiniRequestNotificationKeyDidComplete object:nf];
    });
}

// MARK: - updload

-(NSURLSessionUploadTask *)upload: (NSString *)path
                           params: (NSDictionary *)params
                           header: (NSDictionary *)header
                             file: (NSString *)file
                         fileName: (NSString *)fileName
                         fileType: (NSString *)fileType
{
    
    EMiniUploadRequest * request = [[EMiniUploadRequest alloc] init:path];
    
    request.header = header;
    
    request.body = params;
    
    request.filePath = file;
    
    request.fileType = fileType;
    
    request.fileName = fileName;
    
    return [self reqeust:request];
}

-(NSURLSessionUploadTask *)uploadRequest:(EMiniUploadRequest *)request {
    
    NSString * path = request.path ?: @"";
    
    NSURL * url = [[NSURL alloc] initWithString:path];
    
    if (!url) {
        EMiniMainSafe(^{
            request.complete(nil, nil, [NSError errorWithDomain:@"com.reactnative.neterror" code:NSURLErrorBadURL userInfo:nil]);
        });
        return nil;
    }
    
    NSData * data;
    
    // 本地
    if (request.filePath) {
        NSURL * url = [NSURL fileURLWithPath:request.filePath];
        BOOL isDirectory;
        BOOL exist = [[NSFileManager defaultManager] fileExistsAtPath:request.filePath isDirectory:&isDirectory];
        if (!exist || !url) {
            EMiniMainSafe(^{
                request.complete(nil, nil, [NSError errorWithDomain:@"com.reactnative.neterror" code:NSURLErrorFileDoesNotExist userInfo:nil]);
            });
            return nil;
        }
        if (isDirectory) {
            EMiniMainSafe(^{
                request.complete(nil, nil, [NSError errorWithDomain:@"com.reactnative.neterror" code:NSURLErrorFileIsDirectory userInfo:nil]);
            });
            return nil;
        }
        data = [NSData dataWithContentsOfURL:url];
    }
    // 二进制
    else if (request.fileData) {
        data = request.fileData;
    }
    // 无文件
    if (!data) {
        EMiniMainSafe(^{
            request.complete(nil, nil, [NSError errorWithDomain:@"com.reactnative.neterror" code:NSURLErrorFileDoesNotExist userInfo:nil]);
        });
        return nil;
    }
    
    NSMutableURLRequest * r = [[NSMutableURLRequest alloc] initWithURL:url];
    
    NSString * bundary = [[NSUUID UUID].UUIDString stringByReplacingOccurrencesOfString:@"-" withString:@""];
    
    NSString *contentType = [NSString stringWithFormat:@"multipart/form-data; boundary=%@", bundary];
    
    [r setValue:contentType forHTTPHeaderField:@"Content-Type"];
    
    r.HTTPMethod = @"POST";
    
//    if (request.body && [request.httpMethod.uppercaseString isEqualToString:@"POST"]) {
//        r.HTTPBody = [[EMiniTool objToString:request.body] dataUsingEncoding:NSUTF8StringEncoding];
//    }
    
    if (request.header) {
        for (NSString *key in request.header) {
            [r setValue:request.header[key] forHTTPHeaderField:key];
        }
    }
    for (NSString *key in self.defaultHeaders) {
        [r setValue:request.header[key] forHTTPHeaderField:key];
    }
    
    __weak typeof(EMiniNet *) wSelf = self;
    
    NSData * fromData = [self getSendDataWithFilePath:data boundary:bundary key:request.fileName ?: @"file" fileName: path.lastPathComponent];
    
    r.HTTPBody = fromData;
    
    NSURLSessionUploadTask * task = [self.session dataTaskWithRequest:r
                                                      completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                          EMiniMainSafe(^{
                                                              [wSelf dealForHttpMethod:request data:data response:response error:error];
                                                              [self removeRequest:request];
                                                          });
                                                      }];
    
    request.task = task;
    
    [self addRequest:request];
    
    [task resume];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:EMiniRequestNotificationKeyDidResume object:task];
    });
    
    return task;
    
}

- (NSData *)getSendDataWithFilePath:(NSData *)fileData boundary: (NSString *)boundary key: (NSString *)key fileName: (NSString *)fileName
{
    NSMutableData *body = [NSMutableData dataWithData:fileData];
    
    // 表单拼接
    NSMutableString *headerStrM =[NSMutableString string];
    [headerStrM appendFormat:@"----------%@\r\n",boundary];
    
    // name:表单控件名称 filename:上传文件名
    [headerStrM appendFormat:@"Content-Disposition: form-data; name=%@; filename=%@\r\n",key,fileName];
    [headerStrM appendFormat:@"Content-Type: application/octet-stream\r\n"];
    
    [body appendData:[headerStrM dataUsingEncoding:NSUTF8StringEncoding]];
    [body appendData:fileData];
    
    [body appendData:[[NSString stringWithFormat:@"\r\n--%@--\r\n",boundary] dataUsingEncoding:NSUTF8StringEncoding]];
    
    return body;
}

// MARK: - 下载

- (EMiniRequest *)downLoadByPath:(NSString *)path {
    
    EMiniRequest * request = [[EMiniRequest alloc] init:path];
    
    [self down:request];
    
    return request;
}

- (NSURLSessionDownloadTask *)down: (EMiniRequest *)request {
    
    NSURL * url = [[NSURL alloc] initWithString:request.path];
    
    if (!url) {
        EMiniMainSafe(^{
            request.complete(nil, nil, [NSError errorWithDomain:@"com.reactnative.neterror" code:NSURLErrorBadURL userInfo:nil]);
        });
        return nil;
    }
    
    NSURLSessionDownloadTask * task = [self.session downloadTaskWithURL:url];
    
    request.task = task;
    
    [self addRequest:request];
    
    [task resume];
    
    return task;
}

- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    if (totalBytesExpectedToWrite > 0) {
        EMiniRequest * request = [self requestByTask:downloadTask];
        if (request) {
            double progress = (double)totalBytesWritten / (double)totalBytesExpectedToWrite;
            EMiniMainSafe(^{
                request.progress(progress);
            });
        }
    }
}

- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location {
    
    EMiniRequest * request = [self requestByTask:downloadTask];
    
    if (request) {
        
        NSString * localPath = [location.absoluteString stringByReplacingOccurrencesOfString:@"file://" withString:@""];
        
        NSString * newPath = [localPath stringByAppendingString:@"_copy"];
        
        if ([[NSFileManager defaultManager] copyItemAtURL:location toURL:[NSURL fileURLWithPath:newPath] error:nil]) {
            EMiniMainSafe(^{
                request.complete(newPath, downloadTask.response,nil);
                [self removeRequest:request];
            });
        } else {
            EMiniMainSafe(^{
                request.complete(nil, nil, [NSError errorWithDomain:@"com.reactnative.neterror" code:NSURLErrorCannotWriteToFile userInfo:nil]);
                [self removeRequest:request];
            });
        }
    }
    
}

- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    if (error) {
        EMiniRequest * request = [self requestByTask:task];
        if (request) {
            EMiniMainSafe(^{
                request.complete(nil, task.response, error);
            });
            [self removeRequest:request];
        }
    }
}

- (EMiniRequest *)requestByTask: (NSURLSessionTask *)task {
    EMiniRequest * request;
    for (EMiniRequest * rq in self.tasks) {
        if (rq.task == task) {
            request = rq;
            return request;
        }
    }
    return nil;
}

- (void)removeRequest: (EMiniRequest *)request {
    if (!request) { return; }
    @synchronized (self) {
        if ([self.tasks containsObject:request]) {
            [self.tasks removeObject:request];
        }
    }
}

- (void)addRequest: (EMiniRequest *)request {
    if (!request) { return; }
    @synchronized (self) {
        if (![self.tasks containsObject:request]) {
            [self.tasks addObject:request];
        }
    }
}

@end
