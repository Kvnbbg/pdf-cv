//
//  EMiniApi.m
//  ReactNativeElement
//
//  Created by 王铁山 on 2018/5/10.
//  Copyright © 2018年 王铁山. All rights reserved.
//

#import "EMiniApi.h"

#import "EMiniInfoModel.h"

#import "EMiniNet.h"

#import "EMiniBaseViewController.h"

#import "EMiniTool.h"

#import "EMiniViewManager.h"

Class EMiniBaseClass;

const NSString * EMiniRunErrorNotificationName = @"EMiniRunErrorNotificationName";

static NSDictionary * (^EMiniGetUserInfo)(NSString * miniId);

void EMiniSetGetUserInfoBlock(NSDictionary * (^getUserInfo)()) {
    EMiniGetUserInfo = getUserInfo;
}

@interface EMiniApi()
{
    NSString * _miniId;
}

@property(nonatomic, strong)NSUserDefaults * userDefaults;

@end

@implementation EMiniApi

RCT_EXPORT_MODULE();

+ (instancetype)mimiId:(NSString *)miniId {
    return [[self alloc] init:miniId];
}

- (instancetype)init: (NSString *)miniId {
    NSAssert(miniId.length, @"miniId is invalid");
    self = [super init];
    if (self) {
        _miniId = miniId;
        self. userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@"com.smnimi"];
    }
    return self;
}

- (NSString *)miniId {
    return _miniId;
}


#pragma mark - get info

+ (void)setBaseURL: (NSString *)url {
    if (!url) { return; }
    [[NSUserDefaults standardUserDefaults] setValue:url forKey:@"E_MINI_IP_PORT"];
}

-(NSString *)getBaseURL {
    NSString * url;
#if DEBUG
    url = @"http://mmpt.shenmajr.com/";
#else
    url = @"https://mmp.shenmajr.com/";
#endif
    NSString * local =  [[NSUserDefaults standardUserDefaults] stringForKey:@"E_MINI_IP_PORT"];
    if (local) {
        url = local;
    }
    return url;
}

-(void)getInfo: (void(^)(EMiniInfoModel *))result error: (void(^)(EMiniError))error {
    
    NSDictionary * body = @{@"miniId": _miniId, @"app_version": [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"] ?: @"0.0.0"};
    
    EMiniRequest * request = [[EMiniRequest alloc] init:[NSString stringWithFormat:@"%@%@", [self getBaseURL], @"mini/miniinfo.json"]];
    
    // EMiniRequest * request = [[EMiniRequest alloc] init:@"https://onety.cn/mini/miniinfo.json"];
    
    //EMiniRequest * request = [[EMiniRequest alloc] init:@"http://127.0.0.1:8000/alps/rnminiinfo.json"];
    
    request.httpMethod = @"POST";
    
    request.body = body;
    
    [request setComplete:^(id data, NSURLResponse * response, NSError * netError) {
        
        EMiniMainAsync(^{
            if (netError) {
                error(EMiniErrorNet);
                return;
            }
            
            if ([data isKindOfClass:[NSDictionary class]]) {
                
                if ([data[@"code"] isEqualToString:@"200"]) {
                    
                    EMiniInfoModel * model = [[EMiniInfoModel alloc] init];
                    
                    if (![model parse:data[@"data"]]) {
                        error(EMiniErrorNotFound);
                        return;
                    }
                    
                    [self cacheInfo:model];
                    
                    result(model);
                    
                    return;
                }
            }
        
            error(EMiniErrorNotFound);
            
        });
    }];
    
    [[EMiniNet share] reqeust:request];
    
}

- (EMiniInfoModel *)getCachedMiniInfo {
    return (EMiniInfoModel *)[NSKeyedUnarchiver unarchiveObjectWithFile:[self cachePath]];
}

- (void)cacheInfo: (EMiniInfoModel *)model {
    if (model) {
        NSString * path = [self cachePath];
        BOOL result = [NSKeyedArchiver archiveRootObject:model toFile:path];
        [EMiniTool logInfo:[NSString stringWithFormat:@"cache mini info by ID: %@ %@ to path: %@", self.miniId, result ? @"success" : @"fail", path]];
    }
}

- (void)getUpdateInfo: (void(^)(RNUpdateModel *))result error: (void(^)(EMiniError))error {
    
    // NSDictionary * body = @{@"miniId": _miniId, @"platform": @"iOS", @"f_version": @([self version])};
    // EMiniRequest * request = [[EMiniRequest alloc] init:@"https://onety.cn/mini/miniversion.json"];
    
    NSDictionary * body = @{
                            @"product": _miniId,
                            @"app_version": [[NSBundle mainBundle] infoDictionary][@"CFBundleShortVersionString"] ?: @"0.0.0",
                            @"platform": @"iOS",
                            @"f_version": @([self version])};
    EMiniRequest * request = [[EMiniRequest alloc] init:[NSString stringWithFormat:@"%@%@", [self getBaseURL], @"alps/rnversion.json"]];
    // EMiniRequest * request = [[EMiniRequest alloc] init:@"http://127.0.0.1:8000/alps/rnversion.json"];
    
    request.httpMethod = @"POST";
    
    request.body = body;
    
    [request setComplete:^(id data, NSURLResponse * response, NSError * netError) {
        
        EMiniMainAsync(^{
            if (netError) {
                error(EMiniErrorNet);
                return;
            }
            
            if ([data isKindOfClass:[NSDictionary class]]) {
                
                if ([data[@"code"] isEqualToString:@"200"]) {
                    
                    RNUpdateModel * model = [[RNUpdateModel alloc] init];
                    
                    if (![model parse:data[@"data"]]) {
                        error(EMiniErrorNotFound);
                        return;
                    }
                    
                    result(model);
                    
                    return;
                }
            }
            
            error(EMiniErrorNotFound);
        });
    }];
    
    [[EMiniNet share] reqeust:request];
    
}

- (void)downLoadIcon: (NSString *)path result: (void(^)(UIImage * image))result {
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        if (path) {
            
            UIImage * cachedImage = [self cachedImage:path];
            
            if (cachedImage) {
                EMiniMainAsync(^{
                    result(cachedImage);
                });
                return;
            }
            
            NSURL * url = [NSURL URLWithString:path];
            
            if (url) {
                
                NSData * data = [[NSData alloc] initWithContentsOfURL:url];
                
                if (data) {
                    
                    UIImage * image = [UIImage imageWithData:data];
                    
                    if (image) {
                        
                        [data writeToFile:[self iconCachePath:path] atomically:true];
                        EMiniMainAsync(^{
                            result(image);
                        });
                    }
                }
            }
        }
    });
}

#pragma mark - mini open

+ (void)registBaseClass: (Class) class {
    EMiniBaseClass = class;
}

+ (Class)baseClass {
    return EMiniBaseClass ?: [EMiniBaseViewController class];
}

+ (BOOL)isMini: (NSURL *)url {
    if (url) {
        NSString * path = [url absoluteString];
        if ([path hasPrefix:@"smmini://"]) {
            NSString * subPath = [path stringByReplacingOccurrencesOfString:@"smmini://" withString:@""];
            NSArray * components = [subPath componentsSeparatedByString:@"/"];
            return components.count > 0;
        }
    }
    return false;
}

+ (BOOL)openMiniURL: (NSURL *)url {
    return [self openMiniURL:url class: nil];
}

+ (BOOL)openMiniURL: (NSURL *)url class: (Class)class {
    
    if (url) {
        
        NSString * path = [url absoluteString];
        
        if ([path hasPrefix:@"smmini://"]) {
            
            NSMutableDictionary * params = [NSMutableDictionary dictionary];
            
            NSURLComponents * urlComponents = [[NSURLComponents alloc] initWithString:url.absoluteString];
            
            if (urlComponents.queryItems.count) {
                for (NSURLQueryItem * item in urlComponents.queryItems) {
                    if (item.name && item.value) {
                        params[item.name] = item.value;
                    }
                }
            }
            
            [self openMiniById:urlComponents.host ?: @"" params:params class:class];
            
            return true;
        }
    }
    return false;
}

+ (void)openMiniById: (NSString *)miniId params: (NSDictionary *)params {
    [self openMiniById:miniId params:params class: nil];
}

+ (void)openMiniById: (NSString *)miniId params: (NSDictionary *)params class: (Class)class {
    
    UIViewController * top = [EMiniTool topViewController];
    
    if (!top) {return;}
    
    Class c = class;
    
    if (!c) {
        c = [self baseClass];
    }
    
    EMiniBaseViewController * new = [[c alloc] init:miniId];
    
    NSString * transitionStyle = @"push";
    
    if (params) {
        
        if (params[@"page"]) {
            new.page = params[@"page"];
        }
        
        if (params[@"debug"]) {
            new.debug = [params[@"debug"] boolValue];
        }
        
        if (params[@"debugIp"]) {
            new.debugIp = params[@"debugIp"];
        }
        
        if (params[@"debugPort"]) {
            new.debugPort = params[@"debugPort"];
        }
        
        if (params[@"title"]) {
            new.placeHolderTitle = params[@"title"];
        }
        
        if (params[@"params"]) {
            new.params = params[@"params"];
        }
        
        if (params[@"transitionStyle"]) {
            transitionStyle = params[@"transitionStyle"];
        }
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        if ([transitionStyle isEqualToString: @"present"]) {
            new.transitionStyle = EMiniTransitionStylePresent;
            [top presentViewController:new animated:true completion:nil];
        } else if (top.navigationController && [transitionStyle isEqualToString: @"push"]) {
            [top.navigationController pushViewController:new animated:true];
        } else {
            [top presentViewController:new animated:true completion:nil];
        }
    });
}

// MARK: - 获取用户信息
RCT_EXPORT_METHOD(getUserInfo:(NSString *)miniId callBack: (RCTResponseSenderBlock)callback) {
    NSDictionary * userInfo = @{};
    if (EMiniGetUserInfo) {
        userInfo = EMiniGetUserInfo(miniId) ?: @{};
    }
    callback(@[[NSNull null], [EMiniTool objToString:userInfo]]);
}

#pragma mark - icon method

- (UIImage *)cachedImage: (NSString *)path {
    return [UIImage imageWithContentsOfFile:[self iconCachePath:path]];
}

- (NSString *)iconCachePath: (NSString *)path {
    NSString * fileName = [[[[path stringByReplacingOccurrencesOfString:@":" withString:@""] stringByReplacingOccurrencesOfString:@"/" withString:@""
                             ] stringByReplacingOccurrencesOfString:@"." withString:@""] stringByReplacingOccurrencesOfString:@"-" withString:@""];
    NSString * iconDirectory = [NSString stringWithFormat:@"%@/IconCache", [self rootDirectory]];
    if (![[NSFileManager defaultManager] fileExistsAtPath:iconDirectory]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:iconDirectory withIntermediateDirectories:true attributes:nil error:nil];
    }
    return [NSString stringWithFormat:@"%@/%@", iconDirectory, fileName];
}

#pragma mark - cache method

- (NSString *)cachePath {
    return [NSString stringWithFormat:@"%@/info", [self rootDirectory]];
}

-(int)version {
    NSNumber * save = [self.userDefaults objectForKey:[self versionKey]];
    return save ? [save intValue] : 0;
}

-(void)updateVersion:(NSInteger)version {
    [self.userDefaults setObject:@(version) forKey:[self versionKey]];
    [self.userDefaults synchronize];
}

-(NSString *)versionKey{
    return [NSString stringWithFormat:@"KKMiniProgramVersion%@", _miniId];
}

#pragma mark - bundle

- (BOOL)bundleExist:(int)version {
    return [[NSFileManager defaultManager] fileExistsAtPath:[self bundlePath:version]];
}

- (BOOL)bundlePatchExist:(int)version {
    return [[NSFileManager defaultManager] fileExistsAtPath:[[self bundleDirectory:version] stringByAppendingPathComponent:@"patch"]];
}

- (NSString *)bundlePath:(int)version {
    return [[self bundleDirectory:version] stringByAppendingPathComponent:@"index.jsbundle"];
}

- (NSString *)bundleDirectory:(int)version {
    NSString * directory = [NSString stringWithFormat:@"%@/%d", [self rootDirectory], version];
    if (![[NSFileManager defaultManager] fileExistsAtPath:directory]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:directory withIntermediateDirectories:true attributes:nil error:nil];
    }
    return directory;
}

- (NSString *)rootDirectory {
    NSString * directory = [NSHomeDirectory() stringByAppendingFormat:@"/Library/EMiniCache/%@", self.miniId];
    if (![[NSFileManager defaultManager] fileExistsAtPath:directory]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:directory withIntermediateDirectories:true attributes:nil error:nil];
    }
    return directory;
}
@end
