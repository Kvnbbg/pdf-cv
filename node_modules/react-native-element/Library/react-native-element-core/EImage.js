/**
 * Created by wangtieshan on 2017/7/9.
 */

import React, { Component } from 'react';

import {
    Image,
    ColorPropType,
    TouchableOpacity
} from 'react-native'

import PropTypes from 'prop-types';

/**
 * EImage
 * 此图片组件主要解决图片总是根据图片的实际宽高显示，而导致难以控制的问题
 * 将此组件当做 View 来使用，来布局即可
 *
 * 1. 支持配置图片填充模式
 * 2. 支持设置图片的宽高比例，实现高度根据宽度自动更改
 * 3. 支持根据比例自动跳转图片高度
 * 4. 支持自定义图片下载时请求的配置。请求头、请求体、请求方法、参数等
 * 5. 支持占位图。占位图目前只能是 require 引用的资源
 * 6. 此图片之间支持子节点。类似于 BackgroundImage，但比 BackgroundImage 更容易控制
 * eg:
 * <EImage>
 *     <Text>我是图片中的文本</Text>
 * </EImage>
 * 5. 支持点击事件
 */

export class EImage extends Component {

    static propTypes = {

        /**
         * 图片资源
         */
        source: PropTypes.oneOfType([ PropTypes.number, PropTypes.object ]),

        /**
         * 内容填充模式
         */
        contentMode: PropTypes.oneOf([
            'stretch',
            'contain',
            'cover',
            /**
             * 使用自动高度时
             * 将会通过 aspectRatio 自动调整高度
             */
            'autoHeight'
        ]),

        /**
         * 占位图内容填充模式
         */
        placeHolderContentMode: PropTypes.oneOf([
            'stretch',
            'contain',
            'cover'
        ]),

        /**
         * 点击回调
         */
        onPress: PropTypes.func,

        /**
         * 前景色
         */
        tintColor: ColorPropType,

        /**
         * 设置图片的比例，将会根据此比例自动调整高度，使图片不被压缩、拉伸
         * 高度 / 宽度
         * contentMode 为autoHeight 时，此字段生效。默认 1
         */
        aspectRatio: PropTypes.number,

        /*
        * 占位图片*/
        placeHolder: PropTypes.oneOfType([ PropTypes.number, PropTypes.object ]),

        /**
         * 点击透明度。default: 1
         */
        activeOpacity: PropTypes.number,

        /**
         * 指定请求方法 http method
         */
        method: PropTypes.string,

        /**
         * 指定请求头
         */
        headers: PropTypes.objectOf(PropTypes.string),

        /**
         * 指定请求体
         */
        body: PropTypes.string,

        /*
        * 缓存*/
        cache: PropTypes.oneOf([
            'default',
            'reload',
            'force-cache',
            'only-if-cached',
        ]),
    };

    static defaultProps = {
        aspectRatio: 1,
        contentMode: 'contain',
        placeHolderContentMode: 'contain',
        activeOpacity: 1
    };

    /**
     * 上一次布局的宽高
     */
    lastStyle: { width: number, height: number } = {};

    constructor(props) {
        super(props);
        this.state = {
            selfStyle: {},
            imageStyle: {},
            resizeMode: this.props.contentMode,
            showPlaceholder: true
        };
    }

    reLayout(event) {
        const { width, height } = event.nativeEvent.layout;
        this.lastStyle = { width, height };
        let state = {
            imageStyle: {
                width: width,
                height: height
            }
        };
        if (this.props.contentMode === 'autoHeight') {
            state.selfStyle = { height: width * this.props.aspectRatio };
        }
        this.setState(state);
    }

    _updatePlaceholder(show: boolean) {
        this.setState({
            showPlaceholder: show,
        })
    }

    _observer() {
        // 必须是远端加载，并且存在占位图，才需要监控
        if (this._isRemote(this.props.source) && this.props.placeHolder) {
            return {
                onLoadStart: ()=>{
                    this._updatePlaceholder(true);
                    this.props.onLoadStart && this.props.onLoadStart()
                },
                onLoad: ()=>{
                    this._updatePlaceholder(false);
                    this.props.onLoad && this.props.onLoad()
                },
                onError: (e)=>{
                    this._updatePlaceholder(true);
                    this.props.onError && this.props.onError(e)
                }
            }
        } else {
            return {};
        }
    }

    render() {
        const resizeMode = this.props.contentMode === 'autoHeight' ? 'stretch' : this.props.contentMode;
        return (
            <TouchableOpacity
                onPress={()=>this.props.onPress()}
                disabled={!this.props.onPress}
                activeOpacity={this.props.activeOpacity}
                style={[{ justifyContent: 'center', alignItems: 'center' }, this.props.style, this.state.selfStyle]}
                onLayout={ event => this.reLayout(event) }>
                {/* image */}
                <Image source={this._getFitSource(this.props.source)}
                       style={[{ tintColor: this.props.tintColor, position: 'absolute', top: 0, left: 0 }, this.state.imageStyle ]}
                       resizeMode={resizeMode}
                       { ...this._observer() }/>
                {/* placeholder image */}
                <Image
                    source={this.props.placeHolder}
                    style={[{ position: 'absolute', top: 0, left: 0 },
                        this.state.imageStyle,
                        this.state.showPlaceholder ? {} : { display: 'none' } ]}
                    resizeMode={'contain'}/>
                {this.props.children}
            </TouchableOpacity>
        );
    }

    _isRemote(source): boolean {
        return source && source.hasOwnProperty('uri')
    }

    _getFitSource(source) {
        if (!source) {
            return {};
        }
        if ((typeof source) === 'number') {
            return source;
        }
        if (source.hasOwnProperty('uri')) {
            if (!source.uri) {
                let s = Object.assign({}, source);
                s.uri = '';
                return {};
            }
        } else {
            return {};
        }
        if (!source.hasOwnProperty('method') && this.props.method) {
            source.method = this.props.method;
        }
        if (!source.hasOwnProperty('headers') && this.props.headers) {
            source.headers = this.props.headers;
        }
        if (!source.hasOwnProperty('body') && this.props.body) {
            source.body = this.props.body;
        }
        if (!source.hasOwnProperty('cache') && this.props.cache) {
            source.cache = this.props.cache;
        }
        return source;
    }
}