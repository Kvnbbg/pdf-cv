//
//  File.swift
//  EPreViewImageController
//
//  Created by 王铁山 on 2017/12/7.
//  Copyright © 2017年 king. All rights reserved.
//

import Foundation

import UIKit


/// 预览图片模型
open class EPreViewImageModel: NSObject {
    
    /// 标题
    open var title: String?
    
    /// 预览图片
    open var image: UIImage?
    
    /// 远程路径
    open var path: String?
    
    /// 用于删除定位使用
    open var uuid: String?
    
    public override init() {
        super.init()
    }
    
    public convenience init(image: UIImage) {
        self.init()
        self.image = image
    }
    
    public convenience init(localPath: String) {
        self.init()
        self.image = UIImage.init(contentsOfFile: localPath)
    }
    
    public convenience init(path: String) {
        self.init()
        self.path = path
    }
    
    public func isInvalid() -> Bool {
        if let _ = image {
            return true
        }
        if let _path = path, let _ = URL.init(string: _path) {
            return true
        }
        return false
    }
}


/// 图片预览控制器，使用时直接 modal
open class EPreViewImageController: UIViewController, UIScrollViewDelegate {
    
    /// 删除回调
    open var deleteBlock: ((String?)->Void)?
    
    /// 页数指示器
    open var pageControl: UIPageControl = UIPageControl()
    
    var previewModel: [EPreViewImageModel]
    
    var scrollView: UIScrollView = UIScrollView()
    
    var needDelete: Bool = false
    
    var initIndex: Int = 0
    
    public init(models: [EPreViewImageModel], needDelete: Bool = false, initIndex: Int = 0) {
        self.previewModel = models
        self.needDelete = needDelete
        super.init(nibName: nil, bundle: nil)
    }
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    open override func viewDidLoad() {
        super.viewDidLoad()
        
        UIApplication.shared.setStatusBarHidden(true, with: UIStatusBarAnimation.fade)
        commitInitView()
    }
    
    private func commitInitView() {
        
        self.scrollView.delegate = self
        self.scrollView.bounces = false
        self.scrollView.isPagingEnabled = true
        self.scrollView.frame = self.view.bounds
        self.view.addSubview(self.scrollView)
        
        updateModel(models: previewModel)
        
        let width: CGFloat = self.view.bounds.size.width
        let height: CGFloat = self.view.bounds.size.height
        
        self.scrollView.setContentOffset(CGPoint.init(x: (CGFloat(initIndex) * width), y: 0), animated: true)
        
        self.pageControl.numberOfPages = previewModel.count
        self.pageControl.pageIndicatorTintColor = UIColor.lightGray
        self.pageControl.currentPageIndicatorTintColor = UIColor.white
        self.pageControl.center = CGPoint.init(x: width / 2.0,
                                               y: height - 25)
        self.view.addSubview(self.pageControl)
        
        if needDelete {
            let delete = UIButton.init(type: .custom)
            delete.backgroundColor = UIColor.init(white: 0, alpha: 0.8)
            delete.layer.masksToBounds = true
            delete.layer.cornerRadius = 3
            delete.frame = CGRect.init(x: width - 70, y: 30, width: 50, height: 30)
            delete.titleLabel?.font = UIFont.systemFont(ofSize: 14)
            delete.setTitle("删除", for: UIControlState.normal)
            delete.setTitleColor(UIColor.white, for: UIControlState.normal)
            delete.addTarget(self, action: #selector(deleteAction), for: UIControlEvents.touchUpInside)
            self.view.addSubview(delete)
        }
        
        self.view.addGestureRecognizer(UITapGestureRecognizer.init(target: self, action: #selector(dis)))
    }
    
    func deleteAction() {
        let index = Int(scrollView.contentOffset.x / self.view.frame.size.width)
        guard index < previewModel.count else { return }
        let title: String = previewModel[index].title ?? ("第 ".appending(String(index)).appending(" 张"))
        let alertViewVC = UIAlertController.init(title: "温馨提示", message: "确认删除".appending(title).appending("图片吗？"), preferredStyle: UIAlertControllerStyle.alert)
        alertViewVC.addAction(UIAlertAction.init(title: "取消", style: UIAlertActionStyle.cancel, handler: nil))
        alertViewVC.addAction(UIAlertAction.init(title: "删除", style: UIAlertActionStyle.destructive, handler: { [weak self] (action) in
            guard let wSelf = self else { return }
            wSelf.deleteBlock?(wSelf.previewModel[index].uuid)
            wSelf.previewModel.remove(at: index)
            if wSelf.previewModel.count == 0 {
                wSelf.dismiss(animated: true, completion: nil)
            } else {
                wSelf.updateModel(models: wSelf.previewModel)
            }
        }))
        self.present(alertViewVC, animated: true, completion: nil)
    }
    
    func updateModel(models: [EPreViewImageModel]) {
        
        self.pageControl.numberOfPages = previewModel.count
        
        for view in self.scrollView.subviews {
            if view is EPreViewImageItemView {
                view.removeFromSuperview()
            }
        }
        
        let width: CGFloat = self.view.bounds.size.width
        let height: CGFloat = self.view.bounds.size.height
        var index: CGFloat = 0
        for model in models {
            guard model.isInvalid() else { continue }
            let preview = itemViewByModel(previewModel: model)
            preview.frame = CGRect.init(x: index * width,
                                        y: 0,
                                        width: width,
                                        height: height)
            self.scrollView.addSubview(preview)
            index = index + 1
        }
        self.scrollView.contentSize = CGSize.init(width: index * width, height: height)
        if self.scrollView.contentOffset.x > ((index - 1) * width) {
            self.scrollView.setContentOffset(CGPoint.init(x: (index - 1 * width), y: 0), animated: true)
        }
        self.pageControl.currentPage = Int(scrollView.contentOffset.x / self.view.frame.size.width)
    }
    
    func dis() {
        self.dismiss(animated: true, completion: nil)
    }
    
    private func itemViewByModel(previewModel: EPreViewImageModel) -> EPreViewImageItemView {
        let preview = EPreViewImageItemView.init(frame: self.view.bounds, model: previewModel)
        preview.dismissBLock = { [weak self] in
            self?.dismiss(animated: true, completion: nil)
        }
        return preview
    }
    
    override open var modalPresentationStyle: UIModalPresentationStyle {
        get {
            return .custom
        }
        set {
            
        }
    }
    
    open override var transitioningDelegate: UIViewControllerTransitioningDelegate? {
        get {
            return Trans()
        }
        set {
            
        }
    }
    
    open func scrollViewDidScroll(_ scrollView: UIScrollView) {
        self.pageControl.currentPage = Int(scrollView.contentOffset.x / self.view.frame.size.width)
    }
}


/// 图片预览 item
/// 提供下拉缩小效果，可在其他地方单独使用
open class EPreViewImageItemView: UIView {
    
    open var dismissBLock: (()->Void)?
    
    public init(frame: CGRect, model: EPreViewImageModel) {
        self.model = model
        super.init(frame: frame)
        commitInitView()
        if let image = model.image {
            self.imageView.image = image
        } else {
            beginDownload()
        }
    }
    
    open var scrollView:UIScrollView = UIScrollView()
    
    open var containerView: UIView = UIView()
    
    open var imageView: UIImageView = UIImageView()
    
    var model: EPreViewImageModel
    
    var activity: UIActivityIndicatorView = UIActivityIndicatorView.init(activityIndicatorStyle: UIActivityIndicatorViewStyle.whiteLarge)
    
    required public init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func commitInitView() {
        
        layout()
        
        self.scrollView.bounces = false
        self.scrollView.contentSize = CGSize.init(width: self.frame.size.width, height: self.frame.size.height + 0.2)
        self.addSubview(self.scrollView)
        
        self.containerView.backgroundColor = UIColor.black
        self.containerView.isUserInteractionEnabled = false
        self.scrollView.addSubview(self.containerView)
        self.containerView.addSubview(self.imageView)
        
        self.imageView.frame = self.containerView.bounds
        
        self.imageView.contentMode = UIViewContentMode.scaleAspectFit
        
        self.scrollView.panGestureRecognizer.addTarget(self, action: #selector(scroll(pan:)))
        
        self.addSubview(self.activity)
        
    }
    
    var startPoint: CGPoint?
    
    func beginDownload() {
        guard let _path = model.path, let url = URL.init(string: _path) else {
            return
        }
        self.activity.startAnimating()
        DispatchQueue.global().async { [weak self] in
            guard let wSelf = self else { return }
            do {
                let data = try Data.init(contentsOf: url)
                if let img = UIImage.init(data: data) {
                    DispatchQueue.main.async {
                        wSelf.activity.stopAnimating()
                        wSelf.imageView.image = img
                    }
                } else {
                    DispatchQueue.main.async {
                        wSelf.activity.stopAnimating()
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    wSelf.activity.stopAnimating()
                }
            }
        }
    }
    
    func scroll(pan: UIPanGestureRecognizer) {
        
        let point: CGPoint = pan.location(in: self.containerView)
        
        if pan.state == UIGestureRecognizerState.began {
            self.startPoint = point
        } else if pan.state == UIGestureRecognizerState.failed ||
            pan.state == UIGestureRecognizerState.cancelled ||
            pan.state == UIGestureRecognizerState.ended {
            self.startPoint = nil
            if self.imageView.center.y > self.containerView.bounds.size.height * 4.0 / 5.0 {
                self.dismissBLock?()
                return
            }
            UIView.animate(withDuration: 0.25, animations: {
                self.imageView.frame = self.containerView.bounds
                self.containerView.alpha = 1
            })
        } else if pan.state == UIGestureRecognizerState.changed {
            guard let start = self.startPoint else {
                return
            }
            let height: CGFloat = self.containerView.bounds.size.height
            let width: CGFloat = self.containerView.bounds.size.width
            let y: CGFloat = height / 2.0 + point.y - start.y
            let x: CGFloat = width / 2.0 + point.x - start.x
            self.imageView.center = CGPoint.init(x: x, y: y)
            let half: CGFloat = height / 2.0
            let c: CGFloat = y - half
            let scale: CGFloat = c <= 0 ? 1 : (1 - (c / height))
            self.imageView.bounds = CGRect.init(x: 0,
                                                y: 0,
                                                width: width * scale,
                                                height: height * scale)
            self.containerView.alpha = scale
        }
        
    }
    
    open override func layoutSubviews() {
        super.layoutSubviews()
        layout()
    }
    
    private func layout() {
        self.scrollView.frame = CGRect.init(origin: CGPoint(), size: self.bounds.size)
        self.containerView.frame = self.bounds
        self.activity.center = CGPoint.init(x: self.frame.size.width / 2.0,
                                            y: self.frame.size.height / 2.0)
    }
    
}

private class Trans: NSObject, UIViewControllerTransitioningDelegate {
    
    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        
        return PublicHomePopAnimatedTransitioning(type: .present)
        
    }
    
    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
        
        return PublicHomePopAnimatedTransitioning(type: .dismiss)
    }
    
}


private enum PublicHomeTransitionType {
    
    case present
    case dismiss
}

private class PublicHomePopAnimatedTransitioning: NSObject, UIViewControllerAnimatedTransitioning {
    
    var type: PublicHomeTransitionType = .present
    
    init(type: PublicHomeTransitionType) {
        self.type = type
    }
    
    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
        
        return 0.3
    }
    
    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
        
        let containerView = transitionContext.containerView
        
        containerView.backgroundColor = UIColor.clear
        
        let fromView = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from)?.view ?? UIView()
        
        let toView = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to)?.view ?? UIView()
        
        var view = UIView()
        switch type {
            
        case .present: view = toView
        case .dismiss: view = fromView
        }
        
        view.frame = containerView.frame
        containerView.addSubview(view)
        view.alpha = type == .present ? 0 : 1
        
        UIView.animate(withDuration: transitionDuration(using: transitionContext), animations: {
            
            view.alpha = self.type == .present ? 1 : 0
            
        }, completion: { _ in
            
            let isCancelled = transitionContext.transitionWasCancelled
            transitionContext.completeTransition(!isCancelled)
        })
        
    }
}
