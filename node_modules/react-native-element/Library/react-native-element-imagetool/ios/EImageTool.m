//
//  EImageTool.m
//  T
//
//  Created by 王铁山 on 2017/10/29.
//  Copyright © 2017年 tieshan. All rights reserved.
//

#import "EImageTool.h"

#import <React/RCTUtils.h>

/**
 * 图片公共属性
 */
/**
export interface EImageProperty {
path: string,
subPath: string,
width: number,
height: number,
scale: number,
}
 */

/**
 * 图片压缩配置
 * maxWidth: 压缩后的最大宽度
 * maxHeight: 压缩后的最大高度
 * size: 压缩后的最大大小单位：M
 */
/**
export interface EImageCompressConfig {
maxWidth: number,
maxHeight: number,
size: number,
}
 */

/**
 * 选择图片的配置项
 * sourceType?: album or camera
 * cameraDevice?: front back
 */
/**
export type EPickImageConfig = {
    
    sourceType?: string;
    
    cameraDevice?: string;
}
 */

@interface EImageTool()<UINavigationControllerDelegate, UIImagePickerControllerDelegate>

@property(nonatomic, copy) RCTResponseSenderBlock curPickImageBlock;

@end

@implementation EImageTool

RCT_EXPORT_MODULE();

RCT_EXPORT_METHOD(saveToAlbum: (NSString *)path callBack: (RCTResponseSenderBlock)callback) {
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        if (path) {
            
            if ([path hasPrefix:@"http"]) {
                
                NSString * urlPath = (__bridge_transfer NSString *)CFURLCreateStringByReplacingPercentEscapesUsingEncoding(NULL, (__bridge CFStringRef)path, CFSTR(""), CFStringConvertNSStringEncodingToEncoding(NSUTF8StringEncoding));
                
                NSURL * url = [NSURL URLWithString:urlPath];
                
                if (url) {
                        
                    NSData * data = [[NSData alloc] initWithContentsOfURL:url];
                    
                    if (data) {
                        
                        UIImage * image = [UIImage imageWithData:data];
                        
                        if (image) {
                            UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);
                            return;
                        }
                    }
                    
                    callback(@[[self rnParamsByMessage:@"无效的资源"], [NSNull null]]);
                    
                } else {
                    callback(@[[self rnParamsByMessage:@"无效的路径"], [NSNull null]]);
                }
                
            } else {
                
                UIImage * image = [UIImage imageWithContentsOfFile: path];
                
                if (image) {
                    UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);
                } else {
                    callback(@[[self rnParamsByMessage:@"无效的资源"], [NSNull null]]);
                }
            }
            
        } else {
            callback(@[[self rnParamsByMessage:@"无效的路径"], [NSNull null]]);
        }
    });
    
}


/**
 
 export type ImageProperty = {
 path: string,
 subPath: string,
 width: number,
 height: number,
 scale: number,
 }
 
 export type ImageCompressType = {
 tPath: string,
 maxWidth: number,
 maxHeight: number,
 size: number,
 }
 **/
RCT_EXPORT_METHOD(compressImage: (NSString *)path config:(NSString *)configStr callBack: (RCTResponseSenderBlock)callback) {
    
    NSMutableDictionary * config = [NSMutableDictionary dictionaryWithDictionary: [self stringToObject:configStr]];
    
    UIImage * image = [[UIImage alloc] initWithContentsOfFile:path];
    
    if (!image) {
        callback(@[RCTErrorWithMessage(@"图片不存在"), [NSNull null]]);
        return;
    }
   
    config[@"tPath"] = [[[ path stringByDeletingPathExtension] stringByAppendingString:@"_thumb"] stringByAppendingPathExtension:path.pathExtension];
    
    callback(@[[NSNull null],RCTJSONStringify([self compressImage:image config:config png:[path hasSuffix:@"png"]], nil)]);
}

- (NSDictionary *)compressImage:(UIImage *)image config:(NSDictionary *)config png: (BOOL)png {
    
    UIImage * result = [EImageTool compressWithSize:CGSizeMake([config[@"maxWidth"] floatValue], [config[@"maxHeight"] floatValue]) rate:0.7 image:image diskSize: [config[@"size"] doubleValue]];
    
    NSData * data;
    
    if (png) {
        data = UIImagePNGRepresentation(result);
    } else {
        data = UIImageJPEGRepresentation(result, 1.0);
    }
    
    NSString * tPath = config[@"tPath"];
    
    [data writeToFile:tPath atomically:true];
    
    NSMutableDictionary * params = [self getImageInfo: result];
    
    [params addEntriesFromDictionary:@{ @"path": tPath }];

    return params;
}

/**
 export type NativePickImageConfig = {
 tPath: string,
 originCompress: ImageCompressType,
 thumbCompress: ImageCompressType,
 sourceType?: number,
 multi?: number,
 frontCamera?: number,
 }

 **/
RCT_EXPORT_METHOD(pickImageFromAlbum:(NSString *)configStr callBack: (RCTResponseSenderBlock)callback) {
    
    NSDictionary * configObj = [self stringToObject:configStr];
    
    [self pickImage:configObj callBack:callback];
}

-(void)pickImage:(NSDictionary *)config callBack: (RCTResponseSenderBlock)callback {
    RCTExecuteOnMainQueue(^{
        self.curPickImageBlock = callback;
        UIImagePickerController * pick = [[UIImagePickerController alloc] init];
        if ([config[@"sourceType"] isEqualToString:@"album"]) {
            pick.sourceType = UIImagePickerControllerSourceTypeSavedPhotosAlbum;
        } else {
            pick.sourceType = UIImagePickerControllerSourceTypeCamera;
            if ([config[@"cameraDevice"] isEqualToString:@"front"]) {
                pick.cameraDevice = UIImagePickerControllerCameraDeviceFront;
            } else {
                pick.cameraDevice = UIImagePickerControllerCameraDeviceRear;
            }
        }
        pick.delegate = self;
        [RCTPresentedViewController() presentViewController:pick animated:true completion:nil];
    });
}

- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary<NSString *,id> *)info {
    
    RCTExecuteOnMainQueue(^{
        [picker dismissViewControllerAnimated:true completion:nil];
    });
    
    UIImage * image = [info valueForKey:UIImagePickerControllerOriginalImage];
    
    BOOL png = true;
    
    NSData * data = UIImagePNGRepresentation(image);
    
    if (!data) {
        png = false;
        data = UIImageJPEGRepresentation(image, 1.0);
    }
    
    // 临时路径
    NSString * tPath = RCTTempFilePath(png ? @"png" : @"jpg", nil);
    
    [data writeToFile:tPath atomically:true];
    
    NSMutableDictionary * params = [self getImageInfo: image];
    
    [params addEntriesFromDictionary:@{ @"path": tPath }];

    if (self.curPickImageBlock) {
        
        self.curPickImageBlock(@[[NSNull null], [self jsonToString: params]]);
        
        self.curPickImageBlock = nil;
    }
}

+ (CGRect)fitSize:(CGSize)size container: (CGSize)container {
    
    if (MAX(size.width, size.height) < MIN(container.width, container.height)) {
        
        return CGRectMake((container.width - size.width) / 2.0,
                          (container.height - size.height) / 2.0,
                          size.width,
                          size.height);
    }
    if (size.width / size.height > container.width / container.height) {
        CGFloat realWidth = container.width;
        CGFloat realHeight = realWidth * (size.height / size.width);
        return CGRectMake(0,
                          (container.height - realHeight) / 2.0,
                          realWidth,
                          realHeight);
    } else {
        CGFloat realHeight = container.height;
        CGFloat realWidth = realHeight * (size.width / size.height);
        return CGRectMake((container.width - realWidth) / 2.0,
                          0,
                          realWidth,
                          realHeight);
    }
    
}

-(NSMutableDictionary *) getImageInfo: (UIImage *)image {
    return [NSMutableDictionary dictionaryWithObjectsAndKeys:
            @(image.size.width),
            @"width",
            @(image.size.height),
            @"height",
            @(image.scale),
            @"scale",
            nil];
}

- (NSDictionary *)rnParamsByMessage:(NSString *)message {
    NSError * error = [[NSError alloc] initWithDomain:@"com.kkmini.error" code:500 userInfo: @{@"NSLocalizedDescription": message}];
    return @{
             @"code": [NSString stringWithFormat:@"%ld", error.code],
             @"message": error.localizedDescription,
             };
}

- (id)stringToObject: (NSString *)str {
    return RCTJSONParse(str, nil);
}

- (NSString *)jsonToString:(id)obj {
    return RCTJSONStringify(obj, nil);
}


+ (UIImage *)compressWithSize:(CGSize)size rate: (CGFloat)rate image:(UIImage *)image diskSize:(double)diskSize {
    
    CGSize imageSize = CGSizeMake(image.size.width * image.scale, image.size.height * image.scale);
    
    // 大小小于 1024，则不必更改大小
    if (MAX(imageSize.width, imageSize.height) < diskSize) {
        
        double len = [self sizeOfImage:image];
        
        if (len) {
            
            // 压缩
            if (len > diskSize) {
                return [self representate:image compressionQuality:rate];
            }
            // 合格
            else {
                return image;
            }
        } else {
            return image;
        }
    }
    
    // 大于 1024
    else {
        
        // 大小更改
        UIImage * drawImage = [self redrawImage:[self fitSize:imageSize container:size] image:image];
        
        double len = [self sizeOfImage: drawImage];
        
        if (len) {
            // 仍然大于 0.5M
            if (len > diskSize) {
                return [self representate:drawImage compressionQuality:rate];
            } else {
                // 合格
                return drawImage;
            }
        } else {
            return drawImage;
        }
    }
}

+ (UIImage *)representate: (UIImage *)image compressionQuality:(CGFloat)compressionQuality {
    
    NSData * data = UIImageJPEGRepresentation(image, compressionQuality);
    
    if (!data) {
        return image;
    }
    
    UIImage * img = [UIImage imageWithData:data];
    
    if (img) {
        return img;
    } else {
        return image;
    }
    
}

+ (UIImage *)redrawImage: (CGRect)rect image: (UIImage *)image {
    
    UIGraphicsBeginImageContext(rect.size);
    
    [image drawInRect:CGRectMake(0, 0, rect.size.width, rect.size.height)];
    
    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();
    
    UIGraphicsEndImageContext();
    
    return newImage ?: image;
    
}

+ (double)sizeOfImage: (UIImage *)image {
    NSData * data = UIImageJPEGRepresentation(image, 1.0);
    return [data length] / 1024.0 / 1024.0;
}
@end
