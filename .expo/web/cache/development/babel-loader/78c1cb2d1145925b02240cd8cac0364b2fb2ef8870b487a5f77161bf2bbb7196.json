{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nvar _Recording;\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { PermissionStatus, createPermissionHook, EventEmitter, Platform } from 'expo-modules-core';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound } from './Sound';\nimport { _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS } from '../AV';\nimport ExponentAV from '../ExponentAV';\nvar _recorderExists = false;\nvar eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\nexport function getPermissionsAsync() {\n  return _getPermissionsAsync.apply(this, arguments);\n}\nfunction _getPermissionsAsync() {\n  _getPermissionsAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee14() {\n    return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n      while (1) switch (_context14.prev = _context14.next) {\n        case 0:\n          return _context14.abrupt(\"return\", ExponentAV.getPermissionsAsync());\n        case 1:\n        case \"end\":\n          return _context14.stop();\n      }\n    }, _callee14);\n  }));\n  return _getPermissionsAsync.apply(this, arguments);\n}\nexport function requestPermissionsAsync() {\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nfunction _requestPermissionsAsync() {\n  _requestPermissionsAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee15() {\n    return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) switch (_context15.prev = _context15.next) {\n        case 0:\n          return _context15.abrupt(\"return\", ExponentAV.requestPermissionsAsync());\n        case 1:\n        case \"end\":\n          return _context15.stop();\n      }\n    }, _callee15);\n  }));\n  return _requestPermissionsAsync.apply(this, arguments);\n}\nexport var usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync\n});\nexport var Recording = function () {\n  function Recording() {\n    var _this = this;\n    _classCallCheck(this, Recording);\n    this._subscription = null;\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n    this._cleanupForUnloadedRecorder = function () {\n      var _ref = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(finalStatus) {\n        var _finalStatus$duration;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _this._canRecord = false;\n              _this._isDoneRecording = true;\n              _this._finalDurationMillis = (_finalStatus$duration = finalStatus == null ? void 0 : finalStatus.durationMillis) != null ? _finalStatus$duration : 0;\n              _recorderExists = false;\n              if (_this._subscription) {\n                _this._subscription.remove();\n                _this._subscription = null;\n              }\n              _this._disablePolling();\n              _context.next = 8;\n              return _this.getStatusAsync();\n            case 8:\n              return _context.abrupt(\"return\", _context.sent);\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this._pollingLoop = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(isAudioEnabled() && _this._canRecord && _this._onRecordingStatusUpdate != null)) {\n              _context2.next = 10;\n              break;\n            }\n            _this._progressUpdateTimeoutVariable = setTimeout(_this._pollingLoop, _this._progressUpdateIntervalMillis);\n            _context2.prev = 2;\n            _context2.next = 5;\n            return _this.getStatusAsync();\n          case 5:\n            _context2.next = 10;\n            break;\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](2);\n            _this._disablePolling();\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[2, 7]]);\n    }));\n    this.getStatusAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {\n      var status;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!_this._canRecord) {\n              _context3.next = 2;\n              break;\n            }\n            return _context3.abrupt(\"return\", _this._performOperationAndHandleStatusAsync(function () {\n              return ExponentAV.getAudioRecordingStatus();\n            }));\n          case 2:\n            status = {\n              canRecord: false,\n              isRecording: false,\n              isDoneRecording: _this._isDoneRecording,\n              durationMillis: _this._finalDurationMillis\n            };\n            _this._callOnRecordingStatusUpdateForNewStatus(status);\n            return _context3.abrupt(\"return\", status);\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n  }\n  return _createClass(Recording, [{\n    key: \"_disablePolling\",\n    value: function _disablePolling() {\n      if (this._progressUpdateTimeoutVariable != null) {\n        clearTimeout(this._progressUpdateTimeoutVariable);\n        this._progressUpdateTimeoutVariable = null;\n      }\n    }\n  }, {\n    key: \"_enablePollingIfNecessaryAndPossible\",\n    value: function _enablePollingIfNecessaryAndPossible() {\n      if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n        this._disablePolling();\n        this._pollingLoop();\n      }\n    }\n  }, {\n    key: \"_callOnRecordingStatusUpdateForNewStatus\",\n    value: function _callOnRecordingStatusUpdateForNewStatus(status) {\n      if (this._onRecordingStatusUpdate != null) {\n        this._onRecordingStatusUpdate(status);\n      }\n    }\n  }, {\n    key: \"_performOperationAndHandleStatusAsync\",\n    value: function () {\n      var _performOperationAndHandleStatusAsync2 = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4(operation) {\n        var status;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              throwIfAudioIsDisabled();\n              if (!this._canRecord) {\n                _context4.next = 9;\n                break;\n              }\n              _context4.next = 4;\n              return operation();\n            case 4:\n              status = _context4.sent;\n              this._callOnRecordingStatusUpdateForNewStatus(status);\n              return _context4.abrupt(\"return\", status);\n            case 9:\n              throw new Error('Cannot complete operation because this recorder is not ready to record.');\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _performOperationAndHandleStatusAsync(_x2) {\n        return _performOperationAndHandleStatusAsync2.apply(this, arguments);\n      }\n      return _performOperationAndHandleStatusAsync;\n    }()\n  }, {\n    key: \"setOnRecordingStatusUpdate\",\n    value: function setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n      this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n      if (onRecordingStatusUpdate == null) {\n        this._disablePolling();\n      } else {\n        this._enablePollingIfNecessaryAndPossible();\n      }\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"setProgressUpdateInterval\",\n    value: function setProgressUpdateInterval(progressUpdateIntervalMillis) {\n      this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"prepareToRecordAsync\",\n    value: function () {\n      var _prepareToRecordAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5() {\n        var options,\n          extensionRegex,\n          _yield$ExponentAV$pre,\n          uri,\n          status,\n          currentStatus,\n          _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : RecordingOptionsPresets.LOW_QUALITY;\n              throwIfAudioIsDisabled();\n              if (!_recorderExists) {\n                _context5.next = 4;\n                break;\n              }\n              throw new Error('Only one Recording object can be prepared at a given time.');\n            case 4:\n              if (!this._isDoneRecording) {\n                _context5.next = 6;\n                break;\n              }\n              throw new Error('This Recording object is done recording; you must make a new one.');\n            case 6:\n              if (!(!options || !options.android || !options.ios)) {\n                _context5.next = 8;\n                break;\n              }\n              throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n            case 8:\n              extensionRegex = /^\\.\\w+$/;\n              if (!(!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension))) {\n                _context5.next = 11;\n                break;\n              }\n              throw new Error(\"Your file extensions must match \".concat(extensionRegex.toString(), \".\"));\n            case 11:\n              if (this._canRecord) {\n                _context5.next = 28;\n                break;\n              }\n              if (eventEmitter) {\n                this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n              }\n              _context5.next = 15;\n              return ExponentAV.prepareAudioRecorder(options);\n            case 15:\n              _yield$ExponentAV$pre = _context5.sent;\n              uri = _yield$ExponentAV$pre.uri;\n              status = _yield$ExponentAV$pre.status;\n              _recorderExists = true;\n              this._uri = uri;\n              this._options = options;\n              this._canRecord = true;\n              currentStatus = _objectSpread(_objectSpread({}, status), {}, {\n                canRecord: true\n              });\n              this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n              this._enablePollingIfNecessaryAndPossible();\n              return _context5.abrupt(\"return\", currentStatus);\n            case 28:\n              throw new Error('This Recording object is already prepared to record.');\n            case 29:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function prepareToRecordAsync() {\n        return _prepareToRecordAsync.apply(this, arguments);\n      }\n      return prepareToRecordAsync;\n    }()\n  }, {\n    key: \"getAvailableInputs\",\n    value: (function () {\n      var _getAvailableInputs = _asyncToGenerator(_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", ExponentAV.getAvailableInputs());\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function getAvailableInputs() {\n        return _getAvailableInputs.apply(this, arguments);\n      }\n      return getAvailableInputs;\n    }())\n  }, {\n    key: \"getCurrentInput\",\n    value: (function () {\n      var _getCurrentInput = _asyncToGenerator(_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              return _context7.abrupt(\"return\", ExponentAV.getCurrentInput());\n            case 1:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7);\n      }));\n      function getCurrentInput() {\n        return _getCurrentInput.apply(this, arguments);\n      }\n      return getCurrentInput;\n    }())\n  }, {\n    key: \"setInput\",\n    value: (function () {\n      var _setInput = _asyncToGenerator(_regeneratorRuntime.mark(function _callee8(inputUid) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              return _context8.abrupt(\"return\", ExponentAV.setInput(inputUid));\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8);\n      }));\n      function setInput(_x3) {\n        return _setInput.apply(this, arguments);\n      }\n      return setInput;\n    }())\n  }, {\n    key: \"startAsync\",\n    value: (function () {\n      var _startAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n                return ExponentAV.startAudioRecording();\n              }));\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function startAsync() {\n        return _startAsync.apply(this, arguments);\n      }\n      return startAsync;\n    }())\n  }, {\n    key: \"pauseAsync\",\n    value: (function () {\n      var _pauseAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n                return ExponentAV.pauseAudioRecording();\n              }));\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function pauseAsync() {\n        return _pauseAsync.apply(this, arguments);\n      }\n      return pauseAsync;\n    }())\n  }, {\n    key: \"stopAndUnloadAsync\",\n    value: (function () {\n      var _stopAndUnloadAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee11() {\n        var _stopResult;\n        var stopResult, stopError, status;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (this._canRecord) {\n                _context11.next = 6;\n                break;\n              }\n              if (!this._isDoneRecording) {\n                _context11.next = 5;\n                break;\n              }\n              throw new Error('Cannot unload a Recording that has already been unloaded.');\n            case 5:\n              throw new Error('Cannot unload a Recording that has not been prepared.');\n            case 6:\n              _context11.prev = 6;\n              _context11.next = 9;\n              return ExponentAV.stopAudioRecording();\n            case 9:\n              stopResult = _context11.sent;\n              _context11.next = 15;\n              break;\n            case 12:\n              _context11.prev = 12;\n              _context11.t0 = _context11[\"catch\"](6);\n              stopError = _context11.t0;\n            case 15:\n              if (Platform.OS === 'web' && ((_stopResult = stopResult) == null ? void 0 : _stopResult.uri) !== undefined) {\n                this._uri = stopResult.uri;\n              }\n              _context11.next = 18;\n              return ExponentAV.unloadAudioRecorder();\n            case 18:\n              _context11.next = 20;\n              return this._cleanupForUnloadedRecorder(stopResult);\n            case 20:\n              status = _context11.sent;\n              return _context11.abrupt(\"return\", stopError ? Promise.reject(stopError) : status);\n            case 22:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[6, 12]]);\n      }));\n      function stopAndUnloadAsync() {\n        return _stopAndUnloadAsync.apply(this, arguments);\n      }\n      return stopAndUnloadAsync;\n    }())\n  }, {\n    key: \"getURI\",\n    value: function getURI() {\n      return this._uri;\n    }\n  }, {\n    key: \"createNewLoadedSound\",\n    value: (function () {\n      var _createNewLoadedSound = _asyncToGenerator(_regeneratorRuntime.mark(function _callee12() {\n        var initialStatus,\n          onPlaybackStatusUpdate,\n          _args12 = arguments;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              initialStatus = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};\n              onPlaybackStatusUpdate = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : null;\n              console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");\n              return _context12.abrupt(\"return\", this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate));\n            case 4:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function createNewLoadedSound() {\n        return _createNewLoadedSound.apply(this, arguments);\n      }\n      return createNewLoadedSound;\n    }())\n  }, {\n    key: \"createNewLoadedSoundAsync\",\n    value: (function () {\n      var _createNewLoadedSoundAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee13() {\n        var initialStatus,\n          onPlaybackStatusUpdate,\n          _args13 = arguments;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              initialStatus = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : {};\n              onPlaybackStatusUpdate = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : null;\n              if (!(this._uri == null || !this._isDoneRecording)) {\n                _context13.next = 4;\n                break;\n              }\n              throw new Error('Cannot create sound when the Recording has not finished!');\n            case 4:\n              return _context13.abrupt(\"return\", Sound.createAsync({\n                uri: this._uri\n              }, initialStatus, onPlaybackStatusUpdate, false));\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function createNewLoadedSoundAsync() {\n        return _createNewLoadedSoundAsync.apply(this, arguments);\n      }\n      return createNewLoadedSoundAsync;\n    }())\n  }]);\n}();\n_Recording = Recording;\nRecording.createAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee16() {\n  var options,\n    onRecordingStatusUpdate,\n    progressUpdateIntervalMillis,\n    recording,\n    status,\n    _args16 = arguments;\n  return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n    while (1) switch (_context16.prev = _context16.next) {\n      case 0:\n        options = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : RecordingOptionsPresets.LOW_QUALITY;\n        onRecordingStatusUpdate = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : null;\n        progressUpdateIntervalMillis = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : null;\n        recording = new _Recording();\n        if (progressUpdateIntervalMillis) {\n          recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n        }\n        recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n        _context16.next = 8;\n        return recording.prepareToRecordAsync(_objectSpread(_objectSpread({}, options), {}, {\n          keepAudioActiveHint: true\n        }));\n      case 8:\n        _context16.prev = 8;\n        _context16.next = 11;\n        return recording.startAsync();\n      case 11:\n        status = _context16.sent;\n        return _context16.abrupt(\"return\", {\n          recording: recording,\n          status: status\n        });\n      case 15:\n        _context16.prev = 15;\n        _context16.t0 = _context16[\"catch\"](8);\n        recording.stopAndUnloadAsync();\n        throw _context16.t0;\n      case 19:\n      case \"end\":\n        return _context16.stop();\n    }\n  }, _callee16, null, [[8, 15]]);\n}));\nexport { PermissionStatus };\nexport * from './RecordingConstants';\nexport * from './Recording.types';","map":{"version":3,"names":["PermissionStatus","createPermissionHook","EventEmitter","Platform","isAudioEnabled","throwIfAudioIsDisabled","RecordingOptionsPresets","Sound","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","ExponentAV","_recorderExists","eventEmitter","OS","getPermissionsAsync","_getPermissionsAsync","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee14","wrap","_callee14$","_context14","prev","next","abrupt","stop","requestPermissionsAsync","_requestPermissionsAsync","_callee15","_callee15$","_context15","usePermissions","getMethod","requestMethod","Recording","_this","_classCallCheck","_subscription","_canRecord","_isDoneRecording","_finalDurationMillis","_uri","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","_progressUpdateIntervalMillis","_options","_cleanupForUnloadedRecorder","_ref","_callee","finalStatus","_finalStatus$duration","_callee$","_context","durationMillis","remove","_disablePolling","getStatusAsync","sent","_x","_pollingLoop","_callee2","_callee2$","_context2","setTimeout","t0","_callee3","status","_callee3$","_context3","_performOperationAndHandleStatusAsync","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","_callOnRecordingStatusUpdateForNewStatus","_createClass","key","value","clearTimeout","_enablePollingIfNecessaryAndPossible","_performOperationAndHandleStatusAsync2","_callee4","operation","_callee4$","_context4","Error","_x2","setOnRecordingStatusUpdate","onRecordingStatusUpdate","setProgressUpdateInterval","progressUpdateIntervalMillis","_prepareToRecordAsync","_callee5","options","extensionRegex","_yield$ExponentAV$pre","uri","currentStatus","_args5","_callee5$","_context5","length","undefined","LOW_QUALITY","android","ios","extension","test","concat","toString","addListener","prepareAudioRecorder","_objectSpread","prepareToRecordAsync","_getAvailableInputs","_callee6","_callee6$","_context6","getAvailableInputs","_getCurrentInput","_callee7","_callee7$","_context7","getCurrentInput","_setInput","_callee8","inputUid","_callee8$","_context8","setInput","_x3","_startAsync","_callee9","_callee9$","_context9","startAudioRecording","startAsync","_pauseAsync","_callee10","_callee10$","_context10","pauseAudioRecording","pauseAsync","_stopAndUnloadAsync","_callee11","_stopResult","stopResult","stopError","_callee11$","_context11","stopAudioRecording","unloadAudioRecorder","Promise","reject","stopAndUnloadAsync","getURI","_createNewLoadedSound","_callee12","initialStatus","onPlaybackStatusUpdate","_args12","_callee12$","_context12","console","warn","createNewLoadedSoundAsync","createNewLoadedSound","_createNewLoadedSoundAsync","_callee13","_args13","_callee13$","_context13","createAsync","_callee16","recording","_args16","_callee16$","_context16","keepAudioActiveHint"],"sources":["/home/kevin/Documents/Github/pdf-cv/node_modules/expo-av/src/Audio/Recording.ts"],"sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  RecordingInput,\n  RecordingObject,\n  RecordingOptions,\n  RecordingStatus,\n} from './Recording.types';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound, SoundObject } from './Sound';\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [permissionResponse, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * > **warning** **Warning**: Experimental for web.\n *\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n */\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async (\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<RecordingObject> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync(\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs(): Promise<RecordingInput[]> {\n    return ExponentAV.getAvailableInputs();\n  }\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput(): Promise<RecordingInput> {\n    return ExponentAV.getCurrentInput();\n  }\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid: string): Promise<void> {\n    return ExponentAV.setInput(inputUid);\n  }\n\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\nexport * from './RecordingConstants';\n\nexport * from './Recording.types';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}