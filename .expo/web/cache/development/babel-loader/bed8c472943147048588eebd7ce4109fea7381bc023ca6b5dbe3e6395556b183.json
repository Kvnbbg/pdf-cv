{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\nimport { PitchCorrectionQuality } from './AV.types';\nexport var _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS = 500;\nexport var _DEFAULT_INITIAL_PLAYBACK_STATUS = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  audioPan: 0,\n  isMuted: false,\n  isLooping: false\n};\nexport function getNativeSourceFromSource(source) {\n  var uri = null;\n  var overridingExtension = null;\n  var headers;\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension: overridingExtension,\n      headers: headers\n    };\n  }\n  var asset = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (source != null && typeof source !== 'number' && 'uri' in source && typeof source.uri === 'string') {\n    uri = source.uri;\n  }\n  if (uri == null) {\n    return null;\n  }\n  if (source != null && typeof source !== 'number' && 'overrideFileExtensionAndroid' in source && typeof source.overrideFileExtensionAndroid === 'string') {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n  if (source != null && typeof source !== 'number' && 'headers' in source && _typeof(source.headers) === 'object') {\n    headers = source.headers;\n  }\n  return {\n    uri: uri,\n    overridingExtension: overridingExtension,\n    headers: headers\n  };\n}\nfunction _getAssetFromPlaybackSource(source) {\n  if (source == null) {\n    return null;\n  }\n  var asset = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\nexport function assertStatusValuesInBounds(status) {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n  if (typeof status.audioPan === 'number' && (status.audioPan < -1 || status.audioPan > 1)) {\n    throw new RangeError('Pan value must be between -1.0 and 1.0');\n  }\n}\nexport function getNativeSourceAndFullInitialStatusForLoadAsync(_x, _x2, _x3) {\n  return _getNativeSourceAndFullInitialStatusForLoadAsync.apply(this, arguments);\n}\nfunction _getNativeSourceAndFullInitialStatusForLoadAsync() {\n  _getNativeSourceAndFullInitialStatusForLoadAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee11(source, initialStatus, downloadFirst) {\n    var fullInitialStatus, asset, nativeSource;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) switch (_context11.prev = _context11.next) {\n        case 0:\n          fullInitialStatus = initialStatus == null ? _DEFAULT_INITIAL_PLAYBACK_STATUS : _objectSpread(_objectSpread({}, _DEFAULT_INITIAL_PLAYBACK_STATUS), initialStatus);\n          assertStatusValuesInBounds(fullInitialStatus);\n          if (!(typeof source === 'string' && Platform.OS === 'web')) {\n            _context11.next = 4;\n            break;\n          }\n          return _context11.abrupt(\"return\", {\n            nativeSource: {\n              uri: source,\n              overridingExtension: null\n            },\n            fullInitialStatus: fullInitialStatus\n          });\n        case 4:\n          asset = _getAssetFromPlaybackSource(source);\n          if (!(downloadFirst && asset)) {\n            _context11.next = 8;\n            break;\n          }\n          _context11.next = 8;\n          return asset.downloadAsync();\n        case 8:\n          nativeSource = getNativeSourceFromSource(source);\n          if (!(nativeSource === null)) {\n            _context11.next = 11;\n            break;\n          }\n          throw new Error(\"Cannot load an AV asset from a null playback source\");\n        case 11:\n          if (asset && asset.localUri) {\n            nativeSource.uri = asset.localUri;\n          }\n          return _context11.abrupt(\"return\", {\n            nativeSource: nativeSource,\n            fullInitialStatus: fullInitialStatus\n          });\n        case 13:\n        case \"end\":\n          return _context11.stop();\n      }\n    }, _callee11);\n  }));\n  return _getNativeSourceAndFullInitialStatusForLoadAsync.apply(this, arguments);\n}\nexport function getUnloadedStatus() {\n  var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return _objectSpread({\n    isLoaded: false\n  }, error ? {\n    error: error\n  } : null);\n}\nexport var PlaybackMixin = {\n  playAsync: function () {\n    var _playAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", this.setStatusAsync({\n              shouldPlay: true\n            }));\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, this);\n    }));\n    function playAsync() {\n      return _playAsync.apply(this, arguments);\n    }\n    return playAsync;\n  }(),\n  playFromPositionAsync: function () {\n    var _playFromPositionAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2(positionMillis) {\n      var tolerances,\n        _args2 = arguments;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            tolerances = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            return _context2.abrupt(\"return\", this.setStatusAsync({\n              positionMillis: positionMillis,\n              shouldPlay: true,\n              seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n              seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n            }));\n          case 2:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, this);\n    }));\n    function playFromPositionAsync(_x4) {\n      return _playFromPositionAsync.apply(this, arguments);\n    }\n    return playFromPositionAsync;\n  }(),\n  pauseAsync: function () {\n    var _pauseAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", this.setStatusAsync({\n              shouldPlay: false\n            }));\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3, this);\n    }));\n    function pauseAsync() {\n      return _pauseAsync.apply(this, arguments);\n    }\n    return pauseAsync;\n  }(),\n  stopAsync: function () {\n    var _stopAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", this.setStatusAsync({\n              positionMillis: 0,\n              shouldPlay: false\n            }));\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, this);\n    }));\n    function stopAsync() {\n      return _stopAsync.apply(this, arguments);\n    }\n    return stopAsync;\n  }(),\n  setPositionAsync: function () {\n    var _setPositionAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(positionMillis) {\n      var tolerances,\n        _args5 = arguments;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            tolerances = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n            return _context5.abrupt(\"return\", this.setStatusAsync({\n              positionMillis: positionMillis,\n              seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n              seekMillisToleranceBefore: tolerances.toleranceMillisBefore\n            }));\n          case 2:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5, this);\n    }));\n    function setPositionAsync(_x5) {\n      return _setPositionAsync.apply(this, arguments);\n    }\n    return setPositionAsync;\n  }(),\n  setRateAsync: function () {\n    var _setRateAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee6(rate) {\n      var shouldCorrectPitch,\n        pitchCorrectionQuality,\n        _args6 = arguments;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            shouldCorrectPitch = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : false;\n            pitchCorrectionQuality = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : PitchCorrectionQuality.Medium;\n            return _context6.abrupt(\"return\", this.setStatusAsync({\n              rate: rate,\n              shouldCorrectPitch: shouldCorrectPitch,\n              pitchCorrectionQuality: pitchCorrectionQuality\n            }));\n          case 3:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6, this);\n    }));\n    function setRateAsync(_x6) {\n      return _setRateAsync.apply(this, arguments);\n    }\n    return setRateAsync;\n  }(),\n  setVolumeAsync: function () {\n    var _setVolumeAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee7(volume, audioPan) {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            return _context7.abrupt(\"return\", this.setStatusAsync({\n              volume: volume,\n              audioPan: audioPan\n            }));\n          case 1:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7, this);\n    }));\n    function setVolumeAsync(_x7, _x8) {\n      return _setVolumeAsync.apply(this, arguments);\n    }\n    return setVolumeAsync;\n  }(),\n  setIsMutedAsync: function () {\n    var _setIsMutedAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee8(isMuted) {\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            return _context8.abrupt(\"return\", this.setStatusAsync({\n              isMuted: isMuted\n            }));\n          case 1:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8, this);\n    }));\n    function setIsMutedAsync(_x9) {\n      return _setIsMutedAsync.apply(this, arguments);\n    }\n    return setIsMutedAsync;\n  }(),\n  setIsLoopingAsync: function () {\n    var _setIsLoopingAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee9(isLooping) {\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            return _context9.abrupt(\"return\", this.setStatusAsync({\n              isLooping: isLooping\n            }));\n          case 1:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9, this);\n    }));\n    function setIsLoopingAsync(_x10) {\n      return _setIsLoopingAsync.apply(this, arguments);\n    }\n    return setIsLoopingAsync;\n  }(),\n  setProgressUpdateIntervalAsync: function () {\n    var _setProgressUpdateIntervalAsync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee10(progressUpdateIntervalMillis) {\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            return _context10.abrupt(\"return\", this.setStatusAsync({\n              progressUpdateIntervalMillis: progressUpdateIntervalMillis\n            }));\n          case 1:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10, this);\n    }));\n    function setProgressUpdateIntervalAsync(_x11) {\n      return _setProgressUpdateIntervalAsync.apply(this, arguments);\n    }\n    return setProgressUpdateIntervalAsync;\n  }()\n};\nexport * from './AV.types';","map":{"version":3,"names":["Asset","Platform","PitchCorrectionQuality","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","_DEFAULT_INITIAL_PLAYBACK_STATUS","positionMillis","progressUpdateIntervalMillis","shouldPlay","rate","shouldCorrectPitch","volume","audioPan","isMuted","isLooping","getNativeSourceFromSource","source","uri","overridingExtension","headers","OS","asset","_getAssetFromPlaybackSource","localUri","overrideFileExtensionAndroid","_typeof","fromModule","assertStatusValuesInBounds","status","RangeError","getNativeSourceAndFullInitialStatusForLoadAsync","_x","_x2","_x3","_getNativeSourceAndFullInitialStatusForLoadAsync","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee11","initialStatus","downloadFirst","fullInitialStatus","nativeSource","wrap","_callee11$","_context11","prev","next","_objectSpread","abrupt","downloadAsync","Error","stop","getUnloadedStatus","error","length","undefined","isLoaded","PlaybackMixin","playAsync","_playAsync","_callee","_callee$","_context","setStatusAsync","playFromPositionAsync","_playFromPositionAsync","_callee2","tolerances","_args2","_callee2$","_context2","seekMillisToleranceAfter","toleranceMillisAfter","seekMillisToleranceBefore","toleranceMillisBefore","_x4","pauseAsync","_pauseAsync","_callee3","_callee3$","_context3","stopAsync","_stopAsync","_callee4","_callee4$","_context4","setPositionAsync","_setPositionAsync","_callee5","_args5","_callee5$","_context5","_x5","setRateAsync","_setRateAsync","_callee6","pitchCorrectionQuality","_args6","_callee6$","_context6","Medium","_x6","setVolumeAsync","_setVolumeAsync","_callee7","_callee7$","_context7","_x7","_x8","setIsMutedAsync","_setIsMutedAsync","_callee8","_callee8$","_context8","_x9","setIsLoopingAsync","_setIsLoopingAsync","_callee9","_callee9$","_context9","_x10","setProgressUpdateIntervalAsync","_setProgressUpdateIntervalAsync","_callee10","_callee10$","_context10","_x11"],"sources":["/home/kevin/Documents/Github/pdf-cv/node_modules/expo-av/src/AV.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n  AVPlaybackTolerance,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\n\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  audioPan: 0,\n  isMuted: false,\n  isLooping: false,\n};\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: AVPlaybackNativeSource['headers'];\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n  if (typeof status.audioPan === 'number' && (status.audioPan < -1 || status.audioPan > 1)) {\n    throw new RangeError('Pan value must be between -1.0 and 1.0');\n  }\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\n// @needsAudit\nexport interface AV {\n  /**\n   * Sets a new `AVPlaybackStatusToSet` on the `playbackObject`. This method can only be called if the media has been loaded.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed. See below for details on `AVPlaybackStatus`.\n   */\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * Gets the `AVPlaybackStatus` of the `playbackObject`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject`.\n   */\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\n// @needsAudit\n/**\n * On the `playbackObject` reference, the following API is provided.\n */\nexport interface Playback extends AV {\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   */\n  playAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Loads the media from `source` into memory and prepares it for playing. This must be called before calling `setStatusAsync()`\n   * or any of the convenience set status methods. This method can only be called if the `playbackObject` is in an unloaded state.\n   * @param source The source of the media.\n   * @param initialStatus The initial intended `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. For more information see the details on `AVPlaybackStatusToSet` type\n   * and the default initial playback status.\n   * @param downloadAsync If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `true`. Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is loaded, or rejects if loading failed.\n   * The `Promise` will also reject if the `playbackObject` was already loaded. See below for details on `AVPlaybackStatus`.\n   */\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus?: AVPlaybackStatusToSet,\n    downloadAsync?: boolean\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * Unloads the media from memory. `loadAsync()` must be called again in order to be able to play the media.\n   * > This cleanup function will be automatically called in the `Video` component's `componentWillUnmount`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is unloaded, or rejects if unloading failed.\n   */\n  unloadAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true, positionMillis, seekMillisToleranceAfter: tolerances.seekMillisToleranceAfter, seekMillisToleranceBefore: tolerances.seekMillisToleranceBefore })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false })`.\n   */\n  pauseAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false, positionMillis: 0 })`.\n   */\n  stopAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Replays the playback item. When using `playFromPositionAsync(0)` the item is seeked to the position at `0 ms`.\n   * On iOS this method uses internal implementation of the player and is able to play the item from the beginning immediately.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * `positionMillis` and `shouldPlay` properties will be overridden with respectively `0` and `true`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed.\n   */\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ positionMillis })`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ rate, shouldCorrectPitch, pitchCorrectionQuality })`.\n   * @param rate The desired playback rate of the media. This value must be between `0.0` and `32.0`. Only available on Android API version 23 and later and iOS.\n   * @param shouldCorrectPitch A boolean describing if we should correct the pitch for a changed rate. If set to `true`, the pitch of the audio will be corrected\n   * (so a rate different than `1.0` will timestretch the audio).\n   * @param pitchCorrectionQuality iOS time pitch algorithm setting, defaults to `Audio.PitchCorrectionQuality.Medium`.\n   * Using `Audio.PitchCorrectionQuality.Low` may cause automatic playback rate changes on iOS >= 17, as AVAudioTimePitchAlgorithmLowQualityZeroLatency is deprecated.\n   */\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ volume, audioPan })`.\n   * Note: `audioPan` is currently only supported on Android using `androidImplementation: 'MediaPlayer'`\n   * @param volume A number between `0.0` (silence) and `1.0` (maximum volume).\n   * @param audioPan A number between `-1.0` (full left) and `1.0` (full right).\n   */\n  setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isMuted })`.\n   * @param isMuted A boolean describing if the audio of this media should be muted.\n   */\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isLooping })`.\n   * @param isLooping A boolean describing if the media should play once (`false`) or loop indefinitely (`true`).\n   */\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ progressUpdateIntervalMillis })`.\n   * @param progressUpdateIntervalMillis The new minimum interval in milliseconds between calls of `onPlaybackStatusUpdate`.\n   * See `setOnPlaybackStatusUpdate()` for details.\n   */\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Medium\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume, audioPan });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}